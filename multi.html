<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8">
<title>決策小幫手-建立房間</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<link rel="icon" type="image/png" sizes="32x32" href="icon.png">
<link rel="apple-touch-icon" sizes="180x180" href="icon.png">
<link rel="manifest" href="manifest.json">
<style>
  body {
    font-family: "Segoe UI", sans-serif;
    background-color: #f0f9ff;
    margin: 0;
    padding: 0;
    color: #2c3e50;
  }
  h1 {
    text-align: center;
    padding: 20px 10px;
    margin: 0;
    font-weight: 600;
    font-size: 1.6em;
  }
  .page {
    display: none;
    padding: 20px;
    max-width: 600px;
    margin: auto;
  }
  .page.active {
    display: block;
  }
.btn-primary, .btn-confirm {
  border: none;
  border-radius: 10px;
  padding: 10px 18px;
  font-size: 15px;
  font-weight: 600;
  cursor: pointer;
  box-shadow:
    0 3px 12px -4px #3db8c455, /* 主色系淡陰影 */
    0 1.5px 0 #fff5,           /* 上方一點亮線 */
    0 0.5px 4px #35a4af18;     /* 下方柔和藍暈 */
  transition: background 0.18s, transform 0.09s, box-shadow 0.19s;
  position: relative;
  overflow: hidden;
}

/* --- 質感漸層主按鈕 --- */
.btn-primary {
  background: linear-gradient(120deg, #3db8c4 60%, #35a4af 100%);
  color: #fff;
}
.btn-primary::after {
  content: '';
  display: block;
  position: absolute;
  top: 0; left: 0; right: 0; height: 46%;
  background: linear-gradient(120deg, #fff3 5%, #fff1 100%);
  border-radius: 10px 10px 50% 50% / 38% 38% 55% 55%;
  pointer-events: none;
  z-index: 1;
  opacity: 0.68;
}
.btn-primary:hover {
  background: linear-gradient(120deg, #35a4af 0%, #3db8c4 80%);
  box-shadow:
    0 5px 20px -6px #3db8c488,
    0 2.5px 0 #fff6,
    0 2px 12px #3db8c42e;
  transform: translateY(-1px) scale(1.04);
}
.btn-primary:active {
  background: linear-gradient(120deg, #33a7b3 0%, #43d0e1 100%);
  box-shadow:
    0 1px 6px #3db8c466;
  transform: scale(0.98);
}

/* --- 質感橘紅主按鈕 --- */
.btn-confirm {
  background: linear-gradient(120deg, #fc806d 65%, #ff9a7c 100%);
  color: #fff;
}
.btn-confirm::after {
  content: '';
  display: block;
  position: absolute;
  top: 0; left: 0; right: 0; height: 44%;
  background: linear-gradient(120deg, #fff2 10%, #fff1 100%);
  border-radius: 10px 10px 40% 40% / 36% 36% 60% 60%;
  pointer-events: none;
  z-index: 1;
  opacity: 0.61;
}
.btn-confirm:hover {
  background: linear-gradient(120deg, #ff9a7c 0%, #fc806d 90%);
  box-shadow:
    0 5px 22px -6px #fc806d99,
    0 2.5px 0 #fff6,
    0 2px 12px #ff9a7c26;
  transform: translateY(-1px) scale(1.045);
}
.btn-confirm:active {
  background: linear-gradient(120deg, #fb674a 0%, #fc806d 100%);
  box-shadow:
    0 1px 6px #fc806d55;
  transform: scale(0.97);
}

.btn-confirm-red {
  background: linear-gradient(120deg, #fc3a52 5%, #d7263d 80%, #b31217 100%);
  color: #fff;
  border: none;
  border-radius: 16px;
  padding: 12px 22px;
  font-size: 1.13em;
  font-weight: bold;
  cursor: pointer;
  box-shadow: 
    0 3px 18px -4px #fc3a5244, /* 柔紅光暈 */
    0 1.5px 0 #fff5,           /* 上側微微亮光 */
    0 1.5px 16px #b3121722;    /* 下側投影 */
  transition: background 0.2s, transform 0.11s, box-shadow 0.23s;
  letter-spacing: 1.1px;
  position: relative;
  overflow: hidden;
}

.btn-confirm-red::after {
  content: '';
  display: block;
  position: absolute;
  top: 0; left: 0; right: 0; height: 40%;
  background: linear-gradient(120deg, #fff4 5%, #fff2 90%);
  border-radius: 14px 14px 60% 60% / 30% 30% 60% 60%;
  pointer-events: none;
  z-index: 1;
  opacity: 0.65;
}

.btn-confirm-red:hover {
  background: linear-gradient(120deg, #ff5b70 0%, #fc3a52 50%, #b31217 100%);
  box-shadow:
    0 4px 24px -4px #ff5b705a,
    0 2px 0 #fff6,
    0 2.5px 18px #b3121735;
  transform: translateY(-2px) scale(1.045);
}

.btn-confirm-red:active {
  background: linear-gradient(120deg, #b31217 0%, #fc3a52 90%);
  box-shadow:
    0 1.5px 6px #b3121755;
  transform: scale(0.98);
}

  input {
    padding: 10px;
    font-size: 16px;
    margin: 10px 0;
    border-radius: 8px;
    border: 1px solid #ccc;
    width: 100%;
    box-sizing: border-box;
    transition: border 0.2s, box-shadow 0.2s;
  }
  input:focus {
    border-color: #3db8c4;
    box-shadow: 0 0 5px rgba(61, 184, 196, 0.5);
    outline: none;
  }
  .item-container {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    max-height: calc(1.8em * 3 + 20px);
    overflow-y: auto;
    padding: 6px;
    background: #ffffffcc;
    border-radius: 10px;
  }
  .item-box {
    background: #e0f4ff;
    border-radius: 16px;
    padding: 6px 12px;
    font-size: 14px;
    white-space: nowrap;
    max-width: 150px;
    overflow: hidden;
    text-overflow: ellipsis;
    display: flex;
    align-items: center;
  }
  .remove-btn {
    background: none;
    border: none;
    color: #c0392b;
    font-size: 16px;
    cursor: pointer;
    margin-left: 6px;
    flex-shrink: 0;
  }
  .header-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    flex-wrap: wrap;
    gap: 10px;
    margin-bottom: 12px;
  }
  .modal {
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(0,0,0,0.65);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 9999;
  }
  .modal-content {
    background: white;
    max-width: 90%;
    max-height: 80%;
    overflow-y: auto;
    padding: 20px;
    border-radius: 12px;
    text-align: center;
  }
  .modal-content button {
    margin: 6px 6px;
  }
  .hidden { display: none; }
  @keyframes spin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
  }
  .spin-animation {
      animation: spin 1s linear infinite;
      display: inline-block;
  }
  .result-final {
    font-size: 1.8em;
    color: #3db8c4;
    font-weight: bold;
    animation: pulse 1s infinite;
  }
  @keyframes pulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.1); }
    100% { transform: scale(1); }
  }
  .debug-box {
    position: fixed;
    bottom: 10px;
    right: 10px;
    width: 300px;
    height: 150px;
    background: #f0f0f0;
    border: 1px solid #000;
    overflow-y: auto;
    padding: 10px;
    font-size: 12px;
    z-index: 10000;
    font-family: monospace;
  }
  .debug-box { display: none !important; }

.exit-btn {
  position: fixed;
  top: 14px;
  right: 14px;
  width: 40px;
  height: 40px;
  background: url('https://cdn.jsdelivr.net/gh/a355226/choosehelper@main/exit.jpg') center center no-repeat;
  background-size: 24px 24px;
  border-radius: 50%;
  box-shadow: 0 2px 8px rgba(0,0,0,0.05);
  opacity: 0.7;
  cursor: pointer;
  z-index: 20000;
  transition: opacity 0.2s, box-shadow 0.2s;
  background-color: #e7faf1;
  border: 1.5px solid #dbf4e6;
}
.exit-btn:hover {
  opacity: 1;
  box-shadow: 0 3px 10px rgba(50,150,120,0.18);
  background-color: #d1f7e4;
}

.btn-draw {
  background: linear-gradient(90deg, #FFD267 40%, #FFB85C 100%);
  color: #323e50;
  border: none;
  border-radius: 18px;
  font-size: 1.5em;
  font-weight: 700;
  padding: 18px 38px;
  box-shadow: 0 6px 20px rgba(255, 213, 103, 0.13);
  cursor: pointer;
  transition: background 0.18s, transform 0.08s;
  margin: 22px auto 10px auto;
  display: block;
  letter-spacing: 2px;
}
.btn-draw:hover {
  background: linear-gradient(90deg, #FFB85C 40%, #FFA63C 100%);
  color: #fff;
  transform: scale(1.07);
  box-shadow: 0 8px 24px rgba(255, 184, 92, 0.19);
}

/* 決定方式字體色彩更融合 */
#decideModeDisplay {
  color: #FF7577 !important; /* 較淺紅橘 */
  background: linear-gradient(135deg, rgba(255, 237, 237, 0.78) 0%, rgba(255, 173, 173, 0.28) 100%);
  padding: 4px 16px;
  border-radius: 16px;
  font-weight: bold;
  font-size: 1.1em;
  letter-spacing: 1.2px;
  margin-top: 10px;
  display: inline-block;
  /* 柔和淡淡的陰影 */
  box-shadow: 0 2px 10px 0 rgba(255, 120, 120, 0.10);
  transition: box-shadow 0.19s;
  border: none;
}

.selected-mode-tag {
  color: #1e4661 !important; /* 更深藍灰 */
  background: linear-gradient(120deg, rgba(239,248,255,0.97) 0%, rgba(202,231,255,0.67) 95%);
  padding: 4.5px 18px;
  border-radius: 18px;
  font-weight: bold;
  font-size: 1.12em;
  letter-spacing: 1.15px;
  margin-left: 8px;
  display: inline-block;
  vertical-align: middle;
  border: none;
  box-shadow:
    0 3px 16px 0 rgba(80,185,246,0.09),
    0 2px 7px 0 rgba(130,200,255,0.06),
    0 1.2px 0 #fff3;
  transition: box-shadow 0.22s, background 0.14s, transform 0.14s, color 0.14s;
  position: relative;
  overflow: hidden;
  will-change: background, box-shadow, transform;
}
.selected-mode-tag::before {
  content: '';
  position: absolute;
  inset: 0;
  background: linear-gradient(110deg, #dff8fd22 10%, #aeefff11 80%, #eaf6fb10 100%);
  opacity: 0.32;    /* 更淡 */
  filter: blur(3.8px);
  pointer-events: none;
  z-index: 0;
  animation: tagflow 2.9s ease-in-out infinite alternate;
  border-radius: 18px;
}
.selected-mode-tag::after {
  content: '';
  position: absolute;
  left: 28%; top: 54%;
  width: 36%; height: 35%;
  background: linear-gradient(95deg, #fff8 12%, #eaf8ffad 92%, transparent 100%);
  opacity: 0.18;    /* 幾乎看不見，但有微光 */
  filter: blur(1.8px);
  border-radius: 33% 63% 40% 68% / 51% 54% 29% 52%;
  pointer-events: none;
  z-index: 1;
  transition: opacity 0.16s;
}
/* hover/active 狀態 */
.selected-mode-tag:hover {
  color: #0073a9 !important;
  background: linear-gradient(120deg, #e4f4ff 0%, #bde8fc 95%);
  box-shadow:
    0 7px 24px 0 rgba(48,180,240,0.15),
    0 3px 15px 0 rgba(130,220,255,0.12),
    0 2px 0 #fff5;
  transform: scale(1.04);
}
.selected-mode-tag:active {
  transform: scale(0.97);
  filter: brightness(1.07);
}
.selected-mode-tag:empty { display: none; }
@keyframes tagflow {
  0% { background-position: 0% 38%; }
  100% { background-position: 100% 62%; }
}




/* 動畫區域外框 */
.lottery-animate-frame {
  display: flex;
  align-items: center;
  justify-content: center;
  min-height: 120px;      /* 高度加高一些 */
  min-width: 240px;
  padding: 32px 36px;     /* 上下左右都一樣多 */
  border-radius: 28px;    /* 圓角稍小一點更和諧 */
  background: linear-gradient(120deg, #c2e9fb 0%, #a1c4fd 50%, #70a1ff 100%);
  box-shadow: 0 0 36px 0 rgba(255, 160, 90, 0.09), 0 2px 12px 0 rgba(255,77,79,0.06);
  position: relative;
  overflow: hidden;
  transition: background 0.35s;
}

/* 字體動畫 */
.lottery-animate-text {
  font-size: 2.5em;
  font-weight: 800;
  letter-spacing: 2px;
  color: #FF4D4F;
  text-shadow: 0 4px 24px rgba(255,77,79,0.25), 0 1px 0 #fff;
  animation: pop-in 0.33s cubic-bezier(.52,2.1,.45,.85);
  will-change: transform;
  user-select: none;
  transition: color 0.2s;
}
@keyframes pop-in {
  0%   { transform: scale(0.7) rotate(-7deg);}
  60%  { transform: scale(1.25) rotate(3deg);}
  90%  { transform: scale(0.92);}
  100% { transform: scale(1);}
}
/* 最終定格閃爍效果 */
.lottery-final {
  background: linear-gradient(98deg, #A5252B 0%, #C72A36 44%, #FFD600 51%, #C72A36 58%, #A5252B 100%);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  text-fill-color: transparent;

  font-family: 'Segoe UI', 'PingFang TC', 'Heiti TC', 'Arial', sans-serif;
  font-weight: 900;
  font-size: 2.7em;
  letter-spacing: 2.5px;

  /* 主體深紅，金光偏淡收斂 */
  text-shadow:
    0 1px 5px #FFD60024,     /* 柔和小金暈 */
    0 0 1px #C72A36ee,     /* 主陰影-深紅 */
    0 1.2px 0 #A5252Bdd,     /* 邊緣壓線 */
    0 0 6px #FFD6001a;       /* 補充金光，非常淡 */

  animation: final-glow-redgold 1.2s ease-in-out alternate infinite;
}

@keyframes final-glow-redgold {
  0% {
    text-shadow:
      0 1px 5px #FFD6001a,
      0 0 2.5px #C72A36ee,
      0 1.2px 0 #A5252Bdd,
      0 0 6px #FFD6000f;
  }
  15% {
    text-shadow:
      0 1px 5px #FFD60038,
      0 0 4px #C72A36cc,
      0 1.5px 0 #A5252Bcc,
      0 0 5px #FFD60022;
  }
}
/* 最終結果動畫 - 以亮藍色為基底的顏色閃爍＋漸放大 */
@keyframes blueGrowFlash {
  0%   { color: #0080FF; transform: scale(1);}
  20%  { color: #38A1FF; transform: scale(1.08);}
  40%  { color: #6EC1FF; transform: scale(1.14);}
  60%  { color: #0080FF; transform: scale(1.22);}
  80%  { color: #1677B3; transform: scale(1.13);}
  100% { color: #0080FF; transform: scale(1.25);}
}

.lottery-final-blue {
  font-family: 'Segoe UI', 'PingFang TC', 'Heiti TC', 'Arial', sans-serif;
  font-weight: 900;
  font-size: 2.7em;
  letter-spacing: 2.5px;
  color: #0080FF;
  text-shadow:
    0 1px 8px #bfe2ffcc,
    0 0 4px #0080FF22;
  animation: blueGrowFlash 1.3s cubic-bezier(.65,.13,.31,1.06) infinite alternate;
  transition: color 0.2s, transform 0.2s;
}
@keyframes blue-bg-flash {
  0% {
    background: linear-gradient(120deg, #e3f2fd 0%, #c8e6fa 80%, #bbdefb 100%);
    filter: brightness(1) blur(0.1px);
  }
  35% {
    background: linear-gradient(120deg, #d2ecfa 5%, #b3e6fb 60%, #b6ccf2 100%);
    filter: brightness(1.06) blur(0.25px);
  }
  60% {
    background: linear-gradient(120deg, #caeafc 0%, #e0f4fc 80%, #b3d8f5 100%);
    filter: brightness(1.09) blur(0.4px);
  }
  100% {
    background: linear-gradient(120deg, #e3f2fd 0%, #c8e6fa 80%, #bbdefb 100%);
    filter: brightness(1) blur(0.1px);
  }
}
.lottery-final-bg-blue {
  animation: blue-bg-flash 2.8s cubic-bezier(.75,.13,.19,.95) infinite alternate;
  background: linear-gradient(120deg, #e3f2fd 0%, #c8e6fa 80%, #bbdefb 100%) !important;
}
.selected-mode-tag:empty {
  display: none;
}
#resultArea canvas {
  max-width: 100%;
  height: auto !important;
  display: block;
  margin: auto;
}
</style>
<script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>
<script>
const firebaseConfig = {
    apiKey: "AIzaSyBUbKgC4P7wGFQqZZmgJU890qOe_4yC9kA",
    authDomain: "choosehel.firebaseapp.com",
    databaseURL: "https://choosehel-default-rtdb.asia-southeast1.firebasedatabase.app",
    projectId: "choosehel",
    storageBucket: "choosehel.appspot.com",
    messagingSenderId: "116763876894",
    appId: "1:116763876894:web:1662b36ef2fa815863d80f"
};
firebase.initializeApp(firebaseConfig);
const db = firebase.database();

let userId;
let hasShownReeditSuccess = false;
let hasShownConfirmModal = false;
let hasShownReeditModal = false;
let lastConfirmInitiator = null;
let lastReeditInitiator = null;

// Debug function to log messages to the appropriate debug box
function logDebug(message) {
    const activePage = document.querySelector('.page.active');
    let debugBox;
    if (activePage.id === 'multiPage') {
        debugBox = document.getElementById('multiDebugBox');
    } else if (activePage.id === 'decidePage') {
        debugBox = document.getElementById('decideDebugBox');
    }
    if (debugBox) {
        debugBox.innerHTML += `<p>${new Date().toLocaleTimeString()} - ${message}</p>`;
        debugBox.scrollTop = debugBox.scrollHeight;
    }
}

// Debounce function to reduce repeated Firebase triggers
function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
}

async function createRoom() {
    logDebug("createRoom: Starting room creation");
    const roomName = document.getElementById('roomNameInput').value.trim();
    const verificationCodeInput = document.getElementById('verificationCodeInput').value.trim();
    const userName = document.getElementById('userNameInput').value.trim();

    if (!roomName || !userName) {
        logDebug("createRoom: Missing roomName or userName");
        showModal('請輸入房間名稱和你的名稱', [
            { text: '好的', class: 'btn-confirm', onClick: () => {} }
        ], 'error');
        return;
    }

    let verificationCode = verificationCodeInput || generateVerificationCode();
    const roomIdRaw = `${roomName}-${verificationCode}`;
    const roomId = encodeURIComponent(roomIdRaw);
    const createBtn = document.querySelector('#setupPage .btn-primary');
    createBtn.disabled = true;
    createBtn.innerHTML = '<span class="spin-animation">⏳</span> 建立中...';
    logDebug(`createRoom: Attempting to create/join room ${roomId}`);

    userId = 'user_' + Math.random().toString(36).substr(2, 9);
    localStorage.setItem(`currentUserId_${roomId}`, userId);
    localStorage.setItem('currentRoomId', roomId);
    logDebug(`createRoom: Generated userId ${userId} for user ${userName} in room ${roomId}`);

    const roomRef = db.ref('rooms/' + roomId);
    const maxRetries = 3;
    let attempt = 0;

    while (attempt < maxRetries) {
        try {
            const snapshot = await roomRef.child('participants').once('value');
            const participants = snapshot.val() || {};
            logDebug(`createRoom: Found ${Object.keys(participants).length} participants`);
            if (Object.keys(participants).length === 0) {
                await roomRef.update({
                    finalResult: null,
                    drawResult: null,
                    isDrawing: null,
                    vote: null,
                    confirm: null,
                    editConfirm: null
                });
                logDebug("createRoom: Initialized empty room");
            }
            await roomRef.update({
                name: roomName,
                code: verificationCode,
                creator: userName                
            });
            const participantRef = roomRef.child('participants/' + userId);
            await participantRef.set({ name: userName, lastActive: Date.now() });
participantRef.onDisconnect().remove(); // ← 就這一行
            logDebug(`createRoom: Added user ${userId} (${userName})`);

            document.getElementById('setupPage').classList.remove('active');
            document.getElementById('multiPage').classList.add('active');
            document.getElementById('roomNameDisplay').textContent = `🏠：${roomName} `;
document.getElementById('roomCodeDisplay').textContent = `(🔑：${verificationCode})`;

            logDebug("createRoom: Switched to multiPage");
window.keepAliveTimer && clearInterval(window.keepAliveTimer);
window.keepAliveTimer = setInterval(() => {
  const roomId = localStorage.getItem('currentRoomId');
  const userId = localStorage.getItem(`currentUserId_${roomId}`);
  if (roomId && userId) {
    db.ref(`rooms/${roomId}/participants/${userId}/lastActive`).set(Date.now());
  }
}, 30000); // 每30秒

window.addEventListener('beforeunload', () => {
  clearInterval(window.keepAliveTimer);
});
// ⬆⬆⬆ 到這裡 ⬆⬆⬆
            loadRoomData(roomId);
            listenConfirmation(roomId);
            listenVote(roomId);
            listenReedit(roomId); // 確保重新編輯監聽在房間創建時啟動
            createBtn.disabled = false;
            createBtn.innerHTML = '建立 / 加入';
            logDebug("createRoom: Successfully created/joined room");
            return;
        } catch (error) {
            attempt++;
            logDebug(`createRoom: Error on attempt ${attempt}: ${error.message}`);
            if (attempt === maxRetries) {
                console.error('createRoom: Firebase error after retries:', error);
                showModal('房間建立失敗，請稍後再試！', [
                    { text: '好的', class: 'btn-confirm', onClick: () => {} }
                ], 'error');
                createBtn.disabled = false;
                createBtn.innerHTML = '建立 / 加入';
            }
            await new Promise(resolve => setTimeout(resolve, 1000));
        }
    }
}

function showModal(content, buttons, modalId = 'generic') {
    if (document.querySelector(`.modal[data-modalId="${modalId}"]`)) {
        logDebug(`showModal: Modal ${modalId} already exists, skipping`);
        return;
    }
    closeModalById(modalId);
    const modal = document.createElement('div');
    modal.className = 'modal';
    modal.dataset.modalId = modalId;
    const modalContent = document.createElement('div');
    modalContent.className = 'modal-content';
    modalContent.innerHTML = `<p style="font-size:18px;">${content}</p>`;
    buttons.forEach(btn => {
        const button = document.createElement('button');
        button.className = btn.class || 'btn-primary';
        button.textContent = btn.text;
        button.onclick = () => {
            logDebug(`showModal: Button clicked - ${btn.text} for modal ${modalId}`);
            modal.remove();
            btn.onClick();
        };
        modalContent.appendChild(button);
    });
    modal.appendChild(modalContent);
    document.body.appendChild(modal);
    logDebug(`showModal: Displayed modal ${modalId} with content: ${content}`);
}

function closeModalById(modalId) {
    const modal = document.querySelector(`.modal[data-modalId="${modalId}"]`);
    if (modal) {
        modal.remove();
        logDebug(`closeModalById: Closed modal ${modalId}`);
    }
}

function closeAllModals() {
    document.querySelectorAll('.modal').forEach(modal => {
        logDebug(`closeAllModals: Closing modal ${modal.dataset.modalId}`);
        modal.remove();
    });
}

function loadRoomData(roomId) {
    logDebug("loadRoomData: Loading room data");
     // ⬇⬇⬇ 加在這裡（只要進房就一定會掃描） ⬇⬇⬇
    window.inactiveCleanupTimer && clearInterval(window.inactiveCleanupTimer);
    window.inactiveCleanupTimer = setInterval(() => {
      if (!roomId) return;
      db.ref(`rooms/${roomId}/participants`).once('value').then(snap => {
        const now = Date.now();
        const users = snap.val() || {};
        Object.entries(users).forEach(([uid, obj]) => {
          if (obj.lastActive && now - obj.lastActive > 5*60*1000) { // 2分鐘
            db.ref(`rooms/${roomId}/participants/${uid}`).remove();
          }
        });
      });
    }, 30000);

    window.addEventListener('beforeunload', () => {
      clearInterval(window.inactiveCleanupTimer);
    });
    // ⬆⬆⬆ 到這裡 ⬆⬆⬆
    const roomRef = db.ref('rooms/' + roomId);
    const participantContainer = document.getElementById('participantContainer');
    const listContainer = document.getElementById('listContainer');

    roomRef.child('isDrawing').on('value', snap => {
        const isDrawing = snap.val();
        logDebug(`loadRoomData: isDrawing changed to ${isDrawing}`);
        if (isDrawing) {
            playDrawAnimation(roomId);
        }
    });

// 你的原本監聽 isDrawing
roomRef.child('isDrawing').on('value', snap => {
    const isDrawing = snap.val();
    logDebug(`loadRoomData: isDrawing changed to ${isDrawing}`);
    // 控制抽籤按鈕
    const drawBtn = document.querySelector('#decidePage .btn-draw');
    if (drawBtn) drawBtn.disabled = !!isDrawing;

    if (isDrawing) {
        playDrawAnimation(roomId);
    }
});

// 你的原本監聽 finalResult
roomRef.child('finalResult').on('value', snap => {
    const result = snap.val();
    logDebug(`loadRoomData: finalResult changed to ${result}`);
    // 控制抽籤按鈕
    const drawBtn = document.querySelector('#decidePage .btn-draw');
    if (drawBtn) drawBtn.disabled = !!result; // 結果有值也禁用

    if (result) {
        if (!document.getElementById('decidePage').classList.contains('active')) {
            document.getElementById('multiPage').classList.remove('active');
            document.getElementById('decidePage').classList.add('active');
            document.getElementById('resultArea').innerHTML = '';
    const drawBtn = document.querySelector('#decidePage .btn-draw');
    if (drawBtn) drawBtn.style.display = '';
    const modeBtn = document.querySelector('#decidePage .btn-primary[onclick="chooseDecisionMode()"]');
    if (modeBtn) modeBtn.style.display = '';
    logDebug("loadRoomData: Switched to decidePage due to finalResult");
}
        setTimeout(() => {
            showFinalResult(result);
        }, 150);
    }
});


    roomRef.child('participants').on('value', snapshot => {
        const data = snapshot.val() || {};
        logDebug(`loadRoomData: Participants updated, count: ${Object.keys(data).length}`);
        participantContainer.innerHTML = '';
        const participantCountDisplay = document.getElementById('participantCount');
        if (participantCountDisplay) {
            participantCountDisplay.textContent = `參與者(${Object.keys(data).length}人)：`;
        }

        const decideParticipantContainer = document.getElementById('decideParticipantContainer');
        const decideParticipantCountDisplay = document.getElementById('decideParticipantCount');
        if (decideParticipantContainer) decideParticipantContainer.innerHTML = '';
        if (decideParticipantCountDisplay) {
            decideParticipantCountDisplay.textContent = `參與者(${Object.keys(data).length}人)：`;
        }

        Object.values(data).forEach(p => {
            const div = document.createElement('div');
            div.className = 'item-box';
            div.textContent = p.name;
            participantContainer.appendChild(div);

            if (decideParticipantContainer) {
                const divClone = div.cloneNode(true);
                decideParticipantContainer.appendChild(divClone);
            }
        });
    });

    roomRef.child('list').on('value', snapshot => {
        const items = snapshot.val() || [];
        logDebug(`loadRoomData: List updated, items: ${items.length}`);
        listContainer.innerHTML = '';
        items.forEach((item, index) => {
            const div = document.createElement('div');
            div.className = 'item-box';
            const span = document.createElement('span');
            span.textContent = item;
            const btn = document.createElement('button');
            btn.textContent = '✕';
            btn.className = 'remove-btn';
            btn.onclick = () => removeItem(index);
            div.appendChild(span);
            div.appendChild(btn);
            listContainer.appendChild(div);
        });
    });

    roomRef.child('decisionMode').on('value', snapshot => {
        const mode = snapshot.val() || '';
        logDebug(`loadRoomData: Decision mode changed to ${mode}`);
        document.getElementById('selectedMode').textContent = mode ? `【${mode}】` : '';

        const decideModeDisplay = document.getElementById('decideModeDisplay');
        if (decideModeDisplay) decideModeDisplay.textContent = mode ? `【${mode}】` : '';
    });

    roomRef.child('name').once('value').then(nameSnap => {
    const roomName = nameSnap.val() || '';
    roomRef.child('code').once('value').then(codeSnap => {
        const verificationCode = codeSnap.val() || '';
        const decideRoomNameDisplay = document.getElementById('decideRoomNameDisplay');
        const decideRoomCodeDisplay = document.getElementById('decideRoomCodeDisplay');
        if (decideRoomNameDisplay) decideRoomNameDisplay.textContent = `🏠：${roomName}`;
        if (decideRoomCodeDisplay) decideRoomCodeDisplay.textContent = `(🔑：${verificationCode})`;
        logDebug(`loadRoomData: Room name set to ${roomName}, code: ${verificationCode}`);
    });
});


roomRef.child('isDeciding').on('value', snap => {
    const isDeciding = snap.val();
    logDebug(`loadRoomData: isDeciding changed to ${isDeciding}`);
    const decidePage = document.getElementById('decidePage');
    const multiPage = document.getElementById('multiPage');
    const confirmRef = db.ref(`rooms/${roomId}/confirm`);
    const reeditRef = db.ref(`rooms/${roomId}/editConfirm`);

    if (isDeciding && !decidePage.classList.contains('active')) {
        logDebug("loadRoomData: Switching to decidePage");
        multiPage.classList.remove('active');
        decidePage.classList.add('active');
        confirmRef.off('value');
        confirmRef.remove();
        listenReedit(roomId);
        listenVote(roomId);
// =======【加在這裡】=======
    // 只要進入 decidePage，如果沒有 finalResult，恢復按鈕和清獎狀
    db.ref(`rooms/${roomId}/finalResult`).once('value').then(snap => {
        if (!snap.val()) {
            const drawBtn = document.querySelector('#decidePage .btn-draw');
            if (drawBtn) {
                drawBtn.style.display = '';
                drawBtn.disabled = false;
            }
            const modeBtn = document.querySelector('#decidePage .btn-primary[onclick="chooseDecisionMode()"]');
            if (modeBtn) modeBtn.style.display = '';
document.getElementById('decideModeDisplay').style.display = '';
            document.getElementById('resultArea').innerHTML = '';
        }
    });
    // =========================
    } else if (!isDeciding && !multiPage.classList.contains('active')) {
        logDebug("loadRoomData: Switching to multiPage");
        decidePage.classList.remove('active');
        multiPage.classList.add('active');
        reeditRef.off('value');
        reeditRef.remove();
        confirmRef.remove();
        closeAllModals();
        listenConfirmation(roomId);
    } else if (isDeciding) {
        listenReedit(roomId);
        listenVote(roomId);
    }
});

}

async function addItem() {
    logDebug("addItem: Starting item addition");
    const roomId = localStorage.getItem('currentRoomId');
    const input = document.getElementById('itemInput');
    const value = input.value.trim();
    if (!value) {
        logDebug("addItem: Empty input, aborting");
        return;
    }

    const addBtn = document.querySelector('#multiPage .btn-primary[onclick="addItem()"]');
    addBtn.disabled = true;
    addBtn.innerHTML = '<span class="spin-animation">⏳</span> 新增中...';
    logDebug("addItem: Button disabled, adding item");

    const listRef = db.ref('rooms/' + roomId + '/list');
    const maxRetries = 3;
    let attempt = 0;

    while (attempt < maxRetries) {
        try {
            const snapshot = await listRef.once('value');
            let list = snapshot.val() || [];
            list.push(value);
            await listRef.set(list);
            logDebug(`addItem: Added item ${value} to list`);
            input.value = '';
            addBtn.disabled = false;
            addBtn.innerHTML = '新增項目';
            return;
        } catch (error) {
            attempt++;
            logDebug(`addItem: Error on attempt ${attempt}: ${error.message}`);
            if (attempt === maxRetries) {
                console.error('addItem: Firebase error after retries:', error);
                showModal('新增項目失敗，請稍後再試！', [
                    { text: '好的', class: 'btn-confirm', onClick: () => {} }
                ], 'error');
                addBtn.disabled = false;
                addBtn.innerHTML = '新增項目';
            }
            await new Promise(resolve => setTimeout(resolve, 1000));
        }
    }
}

async function removeItem(index) {
    logDebug(`removeItem: Attempting to remove item at index ${index}`);
    const roomId = localStorage.getItem('currentRoomId');
    const listRef = db.ref('rooms/' + roomId + '/list');
    const maxRetries = 3;
    let attempt = 0;

    while (attempt < maxRetries) {
        try {
            const snapshot = await listRef.once('value');
            let list = snapshot.val() || [];
            list.splice(index, 1);
            await listRef.set(list);
            logDebug(`removeItem: Removed item at index ${index}`);
            return;
        } catch (error) {
            attempt++;
            logDebug(`removeItem: Error on attempt ${attempt}: ${error.message}`);
            if (attempt === maxRetries) {
                console.error('removeItem: Firebase error after retries:', error);
                showModal('移除項目失敗，請稍後再試！', [
                    { text: '好的', class: 'btn-confirm', onClick: () => {} }
                ], 'error');
            }
            await new Promise(resolve => setTimeout(resolve, 1000));
        }
    }
}

function shareRoom() {
    logDebug("shareRoom: Initiating room sharing");
    const roomId = localStorage.getItem('currentRoomId');
    const roomRef = db.ref(`rooms/${roomId}`);

    roomRef.once('value').then(snapshot => {
        const data = snapshot.val() || {};
        const roomName = data.name || '';
        const verificationCode = data.code || '';
        const url = `${location.origin}${location.pathname}?room=${encodeURIComponent(roomName)}&code=${encodeURIComponent(verificationCode)}`;
        logDebug(`shareRoom: Generated share URL: ${url}`);

        showModal('請選擇分享方式', [
            {
                text: '🌐 分享',
                class: 'btn-primary',
                onClick: () => {
                    logDebug("shareRoom: Share button clicked");
                    if (navigator.share) {
                        navigator.share({
                            title: `加入我的選擇房間 - ${roomName}`,
                            text: '點擊快速加入房間！',
                            url
                        }).catch(err => {
                            logDebug(`shareRoom: Share failed: ${err.message}`);
                            showModal('分享失敗: ' + err, [
                                { text: '好的', class: 'btn-confirm', onClick: () => {} }
                            ], 'error');
                        });
                    } else {
                        logDebug("shareRoom: Device does not support sharing");
                        showModal('此裝置不支援直接分享功能', [
                            { text: '好的', class: 'btn-confirm', onClick: () => {} }
                        ], 'error');
                    }
                }
            },
            {
                text: '📋 複製',
                class: 'btn-primary',
                onClick: () => {
                    logDebug("shareRoom: Copy link button clicked");
                    navigator.clipboard.writeText(url)
                        .then(() => {
                            logDebug("shareRoom: Link copied successfully");
                            showModal('已複製連結，可直接貼給朋友！', [
                                { text: '好的', class: 'btn-confirm', onClick: () => {} }
                            ], 'success');
                        })
                        .catch(err => {
                            logDebug(`shareRoom: Copy failed: ${err.message}`);
                            showModal('複製失敗，請手動複製', [
                                { text: '好的', class: 'btn-confirm', onClick: () => {} }
                            ], 'error');
                        });
                }
            },
            {
                text: '⨉',
                class: 'btn-confirm',
                onClick: () => {
                    logDebug("shareRoom: Cancel button clicked");
                }
            }
        ], 'share');
    });
}

function listenConfirmation(roomId) {
    logDebug("listenConfirmation: Starting confirmation listener");
    const confirmRef = db.ref(`rooms/${roomId}/confirm`);
    const modalId = 'confirm';
    let lastProcessedData = null;

    confirmRef.on('value', debounce(async snapshot => {
        const data = snapshot.val();
        const dataString = JSON.stringify(data);
        if (dataString === lastProcessedData) {
            logDebug("listenConfirmation: Data unchanged, skipping");
            return;
        }
        closeModalById(modalId); // 提前關閉模態框
        lastProcessedData = dataString;
        logDebug(`listenConfirmation: Received data: ${dataString}, User: ${userId}`);

        try {
            const roomSnap = await db.ref(`rooms/${roomId}`).once('value');
            const roomData = roomSnap.val() || {};
            const isDeciding = roomData.isDeciding;
            const hasFinalResult = !!roomData.finalResult;
            logDebug(`listenConfirmation: Room state - isDeciding: ${isDeciding}, hasFinalResult: ${hasFinalResult}`);

            if (isDeciding || hasFinalResult) {
                logDebug("listenConfirmation: Terminating due to isDeciding or finalResult");
                closeAllModals();
                await confirmRef.remove();
                confirmRef.off('value');
                return;
            }

if (!data) {
    logDebug("listenConfirmation: No data, skip showing cancel modal");
    closeAllModals();
    // 這裡不要 showModal，因為 confirm 本來就沒有
    return;
}


            if (!data.active || data.status === 'cancelled') {
                logDebug("listenConfirmation: Confirmation cancelled or inactive");
                closeAllModals();
                const cancelledByName = data.cancelledBy ? (await db.ref(`rooms/${roomId}/participants/${data.cancelledBy}`).once('value')).val()?.name || '未知用戶' : '未知用戶';
                showModal(`❌ 確認流程已被 ${cancelledByName} 取消。`, [
                    { text: '好的', class: 'btn-confirm', onClick: () => {} }
                ], 'error');
                await confirmRef.remove();
                return;
            }

            if (data.status !== 'pending') {
                logDebug("listenConfirmation: Not pending, cleaning up");
                closeModalById(modalId);
                return;
            }

            if (!data.initiator || !data.initiatorName) {
                logDebug("listenConfirmation: Invalid initiator data, ignoring");
                await confirmRef.remove();
                closeModalById(modalId);
                showModal('❌ 確認流程無效，已取消。', [
                    { text: '好的', class: 'btn-confirm', onClick: () => {} }
                ], 'error');
                return;
            }

            const participantSnap = await db.ref(`rooms/${roomId}/participants`).once('value');
            const participants = participantSnap.val() || {};
            const total = Object.keys(participants).length;
            const responses = data.responses || {};
            const agreeCount = Object.values(responses).filter(v => v === true).length;
            const disagreeCount = Object.values(responses).filter(v => v === false).length;

            // 確保票數更新
            await confirmRef.update({
                agreeCount: agreeCount,
                disagreeCount: disagreeCount
            });
            logDebug(`listenConfirmation: Updated counts - Agree: ${agreeCount}, Disagree: ${disagreeCount}`);

            const progressText = `（目前 ${agreeCount} 人同意，${disagreeCount} 人不同意）`;

            if (disagreeCount > 0) {
                logDebug("listenConfirmation: Someone disagreed, cancelling");
                await confirmRef.update({ status: 'cancelled', active: false });
                closeAllModals();
                showModal(`❌ 有人不同意清單<br>（${agreeCount} 同意，${disagreeCount} 不同意），流程已取消。`, [
                    { text: '好的', class: 'btn-confirm', onClick: () => {} }
                ], 'error');
                await confirmRef.remove();
                return;
            }

            if (agreeCount === total && total > 0) {
                logDebug("listenConfirmation: All agreed, switching to decidePage");
                await confirmRef.update({ status: 'completed', active: false });
                await db.ref(`rooms/${roomId}/isDeciding`).set(true);
                const multiPage = document.getElementById('multiPage');
                const decidePage = document.getElementById('decidePage');
                if (!decidePage.classList.contains('active')) {
                    logDebug("listenConfirmation: Forcing switch to decidePage");
                    multiPage.classList.remove('active');
                    decidePage.classList.add('active');
                    showModal('✅ 所有人同意，進入抽籤頁面！', [
                        { text: '好的', class: 'btn-confirm', onClick: () => {} }
                    ], 'success');
                }
                return;
            }

            if (responses[userId] === true) {
                logDebug("listenConfirmation: User has agreed, showing waiting modal");
                showWaitingModal(confirmRef, userId, `已同意，等待其他人同意中... <br>${progressText}`, modalId);
                return;
            }

            logDebug("listenConfirmation: Showing confirmation modal for user");
closeAllModals();
            showModal(`已發起清單確認，是否同意？<br>${progressText}`, [
                {
                    text: '同意',
                    class: 'btn-confirm',
                    onClick: async () => {
                        logDebug("listenConfirmation: User agrees");
                        await confirmRef.child('responses').child(userId).set(true);
                        showWaitingModal(confirmRef, userId, `已同意，等待其他人同意中...<br> ${progressText}`, modalId);
                    }
                },
                {
                    text: '不同意',
                    class: 'btn-primary',
                    onClick: async () => {
                        logDebug("listenConfirmation: User disagrees");
                        await confirmRef.child('responses').child(userId).set(false);
                    }
                }
            ], modalId);
        } catch (error) {
            logDebug(`listenConfirmation: Error: ${error.message}`);
            showModal('處理確認流程失敗，請稍後再試！', [
                { text: '好的', class: 'btn-confirm', onClick: () => {} }
            ], 'error');
        }
    }, 500));
}

async function requestConfirmation() {
    logDebug("requestConfirmation: Starting confirmation request");
    const roomId = localStorage.getItem('currentRoomId');
    const userId = localStorage.getItem(`currentUserId_${roomId}`);
    if (!userId) {
        logDebug("requestConfirmation: No userId found in localStorage");
        showModal('用戶身份驗證失敗，請重新加入房間！', [
            { text: '好的', class: 'btn-confirm', onClick: () => { window.location.reload(); } }
        ], 'error');
        return;
    }
    logDebug(`requestConfirmation: Current userId: ${userId}`);
    const confirmRef = db.ref(`rooms/${roomId}/confirm`);
    const confirmBtn = document.querySelector('.btn-confirm-red');
    confirmBtn.disabled = true;
    confirmBtn.innerHTML = '<span class="spin-animation">⏳</span> 提交中...';
    logDebug("requestConfirmation: Button disabled, initiating request");

    try {
        const modeSnap = await db.ref(`rooms/${roomId}/decisionMode`).once('value');
        const mode = modeSnap.val();
        if (!mode) {
            logDebug("requestConfirmation: No decision mode selected");
            showModal('請先選擇決定方式！', [
                { text: '好的', class: 'btn-confirm', onClick: () => {} }
            ], 'error');
            confirmBtn.disabled = false;
            confirmBtn.innerHTML = '我同意此清單';
            return;
        }

        const isDecidingSnap = await db.ref(`rooms/${roomId}/isDeciding`).once('value');
        if (isDecidingSnap.exists() && isDecidingSnap.val() === true) {
            logDebug("requestConfirmation: Room is already deciding");
            showModal('房間正在進行決定中，請稍後再試！', [
                { text: '好的', class: 'btn-confirm', onClick: () => {} }
            ], 'error');
            confirmBtn.disabled = false;
            confirmBtn.innerHTML = '我同意此清單';
            return;
        }

        const participantSnap = await db.ref(`rooms/${roomId}/participants/${userId}`).once('value');
        if (!participantSnap.exists()) {
            logDebug("requestConfirmation: UserId not found in participants");
            showModal('用戶身份無效，請重新加入房間！', [
                { text: '好的', class: 'btn-confirm', onClick: () => { window.location.reload(); } }
            ], 'error');
            confirmBtn.disabled = false;
            confirmBtn.innerHTML = '我同意此清單';
            return;
        }

        await confirmRef.transaction(currentData => {
            logDebug("requestConfirmation: Clearing confirm data via transaction");
            return null;
        });
        const userName = participantSnap.val().name || '未知';
        await confirmRef.set({
            active: true,
            initiator: userId,
            initiatorName: userName,
            status: 'pending',
            responses: {},
            agreeCount: 0,    // 新增：初始化同意票數
            disagreeCount: 0, // 新增：初始化不同意票數
            timestamp: firebase.database.ServerValue.TIMESTAMP
        });
        logDebug(`requestConfirmation: Set confirm data for initiator ${userName} (${userId})`);
        showWaitingModal(confirmRef, userId, '已發起清單確認，等待所有人同意...', 'confirm');
        confirmBtn.disabled = false;
        confirmBtn.innerHTML = '我同意此清單';
    } catch (error) {
        logDebug(`requestConfirmation: Firebase error: ${error.message}`);
        console.error('requestConfirmation: Firebase 設定錯誤:', error);
        showModal('確認流程啟動失敗，請稍後再試！', [
            { text: '好的', class: 'btn-confirm', onClick: () => {} }
        ], 'error');
        confirmBtn.disabled = false;
        confirmBtn.innerHTML = '我同意此清單';
    }
}

function showWaitingModal(ref, userId, message, modalId) {
    logDebug(`showWaitingModal: Displaying waiting modal ${modalId}`);
    showModal(message, [
        {
            text: '取消',
            class: 'btn-primary',
            onClick: async () => {
                logDebug(`showWaitingModal: Cancel button clicked for ${modalId} by user ${userId}`);
                try {
                    await ref.update({
                        status: 'cancelled',
                        active: false,
                        cancelledBy: userId,
                        timestamp: firebase.database.ServerValue.TIMESTAMP
                    });
                    logDebug(`showWaitingModal: Set ${modalId} to cancelled state`);
                    closeModalById(modalId);
                } catch (error) {
                    logDebug(`showWaitingModal: Error setting cancelled state: ${error.message}`);
                    showModal('取消流程失敗，請稍後再試！', [
                        { text: '好的', class: 'btn-confirm', onClick: () => {} }
                    ], 'error');
                }
            }
        }
    ], modalId);
}

async function startDraw() {
    logDebug("startDraw: Starting draw process");
    const drawBtn = document.querySelector('#decidePage .btn-draw');
    drawBtn.disabled = true;
    drawBtn.innerHTML = '<span class="spin-animation">⏳</span> 檢查中...';
    const roomId = localStorage.getItem('currentRoomId');
    const roomRef = db.ref(`rooms/${roomId}`);

    try {
        // ★★★ 1. 防呆多重流程狀態檢查
        // 只要有任一流程（finalResult、vote、confirm、editConfirm）還沒結束就不能抽
        const [finalResultSnap, voteSnap, confirmSnap, editConfirmSnap, isDecidingSnap] = await Promise.all([
            roomRef.child('finalResult').once('value'),
            roomRef.child('vote').once('value'),
            roomRef.child('confirm').once('value'),
            roomRef.child('editConfirm').once('value'),
            roomRef.child('isDeciding').once('value')
        ]);
        const hasFinalResult = !!finalResultSnap.val();
        const hasActiveVote = !!(voteSnap.val() && voteSnap.val().active);
        const hasActiveConfirm = !!(confirmSnap.val() && confirmSnap.val().active);
        const hasActiveEdit = !!(editConfirmSnap.val() && editConfirmSnap.val().active);
        const isDeciding = !!isDecidingSnap.val();

        if (hasFinalResult || hasActiveVote || hasActiveConfirm || hasActiveEdit || !isDeciding) {
            let reason = '';
            if (hasFinalResult) reason = '本次結果已經產生，請重新編輯清單以進行新一輪抽籤！';
            else if (hasActiveVote) reason = '尚有一輪投票正在進行，請先完成投票或等待流程結束。';
            else if (hasActiveConfirm) reason = '清單確認流程尚未結束，請先全部同意或等待流程結束。';
            else if (hasActiveEdit) reason = '有編輯確認流程尚未結束，請先全部同意或等待流程結束。';
            else reason = '目前不在抽籤流程狀態，請重新確認！';

            showModal(reason, [
                { text: '好的', class: 'btn-confirm', onClick: () => {} }
            ], 'error');
            drawBtn.disabled = false;
            drawBtn.innerHTML = '🎲 開始抽籤';
            return;
        }

        // ★★★ 2. 取得抽籤鎖
        const txResult = await roomRef.child('isDrawing').transaction(current => {
            if (current) return; // 有人正在抽籤，不動
            return userId;       // 把 userId 當抽籤鎖
        });

        if (!txResult.committed) {
            showModal('已有人正在抽籤，請等待結果...', [
                { text: '好的', class: 'btn-confirm', onClick: () => {} }
            ], 'info');
            drawBtn.disabled = false;
            drawBtn.innerHTML = '🎲 開始抽籤';
            return;
        }

        // ★★★ 3. 項目檢查與抽籤
        const [listSnap, modeSnap] = await Promise.all([
            roomRef.child('list').once('value'),
            roomRef.child('decisionMode').once('value')
        ]);
        const items = listSnap.val() || [];
        const mode = modeSnap.val() || '一抽入魂';
        logDebug(`startDraw: Items count: ${items.length}, Mode: ${mode}`);

        if (items.length === 0) {
            logDebug("startDraw: No items to draw");
            showModal('⚠️ 目前沒有可抽籤的項目', [
                { text: '好的', class: 'btn-confirm', onClick: () => {} }
            ], 'error');
            await roomRef.child('isDrawing').set(null); // 還原鎖
            drawBtn.disabled = false;
            drawBtn.innerHTML = '🎲 開始抽籤';
            return;
        }

        // 產生項目
        const finalItem = items[Math.floor(Math.random() * items.length)];
        const spinList = [];
        for (let i = 0; i < 35; i++) {
            spinList.push(items[Math.floor(Math.random() * items.length)]);
        }
        spinList.push(finalItem);
        logDebug(`startDraw: Generated spinList, finalItem: ${finalItem}`);

        // 記錄結果
        await roomRef.update({
            isDrawing: userId,
            drawResult: finalItem,
            drawAnimation: spinList,
            vote: null // Clear vote data before draw
        });
        logDebug("startDraw: Updated Firebase with draw data");
        drawBtn.disabled = false;
        drawBtn.innerHTML = '🎲 開始抽籤';
    } catch (error) {
        logDebug(`startDraw: Firebase error: ${error.message}`);
        await db.ref(`rooms/${roomId}/isDrawing`).set(null); // 錯誤要釋放鎖
        showModal('抽籤失敗，請稍後再試！', [
            { text: '好的', class: 'btn-confirm', onClick: () => {} }
        ], 'error');
        drawBtn.disabled = false;
        drawBtn.innerHTML = '🎲 開始抽籤';
    }
}


function chooseDecisionMode() {
    logDebug("chooseDecisionMode: Opening decision mode modal");
    showModal('選擇決定方式', [
        { text: '一抽入魂', onClick: () => setDecisionMode('一抽入魂') },
        { text: '多數決', onClick: () => setDecisionMode('多數決') },
        { text: '共識決', onClick: () => setDecisionMode('共識決') }
    ], 'decisionMode');
}

async function setDecisionMode(mode) {
    logDebug(`setDecisionMode: Setting mode to ${mode}`);
    const roomId = localStorage.getItem('currentRoomId');
    try {
        await db.ref(`rooms/${roomId}/decisionMode`).set(mode);
        document.getElementById('selectedMode').textContent = `【${mode}】`;
        logDebug(`setDecisionMode: Successfully set mode ${mode}`);
    } catch (error) {
        logDebug(`setDecisionMode: Firebase error: ${error.message}`);
        console.error('setDecisionMode: Firebase error:', error);
        showModal('設置決定方式失敗，請稍後再試！', [
            { text: '好的', class: 'btn-confirm', onClick: () => {} }
        ], 'error');
    }
}

function showFinalResult(result) {

    // 1. 隱藏抽籤按鈕和決定方式
    const drawBtn = document.querySelector('#decidePage .btn-draw');
    if (drawBtn) drawBtn.style.display = 'none';
    const modeBtn = document.querySelector('#decidePage .btn-primary[onclick="chooseDecisionMode()"]');
    if (modeBtn) modeBtn.style.display = 'none';

    logDebug(`showFinalResult: Displaying final result: ${result}`);
    const roomId = localStorage.getItem('currentRoomId');
    const confirmRef = db.ref(`rooms/${roomId}/confirm`);
    const reeditRef = db.ref(`rooms/${roomId}/editConfirm`);
    const voteRef = db.ref(`rooms/${roomId}/vote`);

    confirmRef.remove();
    reeditRef.remove();
    voteRef.remove();
    voteRef.off('value');
    closeAllModals();
    logDebug("showFinalResult: Cleared confirm, reedit, and vote data");

    const modal = document.createElement('div');
    modal.className = 'modal';
    modal.dataset.modalId = 'finalResult';
    const modalContent = document.createElement('div');
    modalContent.className = 'modal-content';
    modalContent.innerHTML = `
        <h2 style="font-size:2em;">🎉 最終結果 🎉</h2>
        <p style="font-size:1.8em; color:#3db8c4; font-weight:bold; margin: 20px 0;">${result}</p>
        <p style="font-size:1em;">結果已出爐，請務必遵守哦！</p>
    `;

    confettiEffect();

    const btn = document.createElement('button');
btn.className = 'btn-confirm';
btn.textContent = '關閉';
btn.onclick = () => {
    logDebug("showFinalResult: Close button clicked");
    modal.remove();
    safeEnableDrawBtn(); // ← 使用冷卻機制啟用按鈕
};

modalContent.appendChild(btn);
    modal.appendChild(modalContent);
    document.body.appendChild(modal);
 showCertificate(result);
}

function confettiEffect() {
    logDebug("confettiEffect: Starting confetti animation");
    for (let i = 0; i < 30; i++) {
        const confetti = document.createElement('div');
        confetti.textContent = '🎊';
        confetti.style.position = 'fixed';
        confetti.style.top = '-50px';
        confetti.style.left = Math.random() * 100 + 'vw';
        confetti.style.fontSize = '2em';
        confetti.style.animation = `fall ${2 + Math.random() * 3}s linear forwards`;
        document.body.appendChild(confetti);
        confetti.addEventListener('animationend', () => {
            confetti.remove();
        });
    }
}

async function initiateVoting(mode, finalItem) {
    logDebug(`initiateVoting: Starting voting for item ${finalItem}, mode: ${mode}`);
    const roomId = localStorage.getItem('currentRoomId');
    const voteRef = db.ref(`rooms/${roomId}/vote`);
    try {
        if (!finalItem) {
            logDebug("initiateVoting: Invalid finalItem");
            showModal('抽籤結果無效，請重新抽籤！', [
                { text: '好的', class: 'btn-confirm', onClick: () => {} }
            ], 'error');
            return;
        }
        // 先檢查是否已經有投票資料，沒有再寫
        const voteSnap = await voteRef.once('value');
        if (voteSnap.exists()) {
            logDebug("initiateVoting: Voting already initialized, skip.");
            return;
        }
        await voteRef.set({
            active: true,
            item: finalItem,
            mode: mode,
            votes: {},
            timestamp: firebase.database.ServerValue.TIMESTAMP
        });
        logDebug("initiateVoting: Voting initialized");
    } catch (error) {
        logDebug(`initiateVoting: Firebase error: ${error.message}`);
        showModal('投票啟動失敗，請稍後再試！', [
            { text: '好的', class: 'btn-confirm', onClick: () => {} }
        ], 'error');
    }
}


async function requestReedit() {
    logDebug("requestReedit: Starting reedit request");
    const roomId = localStorage.getItem('currentRoomId');
    const userId = localStorage.getItem(`currentUserId_${roomId}`);
    if (!userId) {
        logDebug("requestReedit: No userId found in localStorage");
        showModal('用戶身份驗證失敗，請重新加入房間！', [
            { text: '好的', class: 'btn-confirm', onClick: () => { window.location.reload(); } }
        ], 'error');
        return;
    }
    logDebug(`requestReedit: Current userId: ${userId}`);
    const reeditRef = db.ref(`rooms/${roomId}/editConfirm`);
    const reeditBtn = document.querySelector('#decidePage .btn-primary[onclick="requestReedit()"]');
    reeditBtn.disabled = true;
    reeditBtn.innerHTML = '<span class="spin-animation">⏳</span> 提交中...';
    logDebug("requestReedit: Button disabled, initiating request");

    try {
        const participantSnap = await db.ref(`rooms/${roomId}/participants/${userId}`).once('value');
        if (!participantSnap.exists()) {
            logDebug("requestReedit: UserId not found in participants");
            showModal('用戶身份無效，請重新加入房間！', [
                { text: '好的', class: 'btn-confirm', onClick: () => { window.location.reload(); } }
            ], 'error');
            reeditBtn.disabled = false;
            reeditBtn.innerHTML = '← 重新編輯';
            return;
        }

        // 改動：移除自動同意，僅設置重新編輯請求
        await reeditRef.transaction(currentData => {
            logDebug("requestReedit: Clearing reedit data via transaction");
            return null;
        });
        const userName = participantSnap.val().name || '未知';
        await reeditRef.set({
            active: true,
            initiator: userId,
            initiatorName: userName,
            status: 'pending',
            responses: {}, // 改動：不預設發起人同意
            timestamp: firebase.database.ServerValue.TIMESTAMP
        });
        logDebug(`requestReedit: Set reedit data for initiator ${userName} (${userId})`);
        showWaitingModal(reeditRef, userId, '已發起重新編輯，等待所有人同意...', 'reedit');
        reeditBtn.disabled = false;
        reeditBtn.innerHTML = '← 重新編輯';
    } catch (error) {
        logDebug(`requestReedit: Firebase error: ${error.message}`);
        console.error('requestReedit: Firebase 設定錯誤:', error);
        showModal('重新編輯請求失敗，請稍後再試！', [
            { text: '好的', class: 'btn-confirm', onClick: () => {} }
        ], 'error');
        reeditBtn.disabled = false;
        reeditBtn.innerHTML = '← 重新編輯';
    }
}

function listenReedit(roomId) {
    logDebug("listenReedit: Starting reedit listener");
    const reeditRef = db.ref(`rooms/${roomId}/editConfirm`);
    const modalId = 'reedit';
    let lastProcessedData = null;

    reeditRef.on('value', debounce(async snap => {
        const data = snap.val();
        const dataString = JSON.stringify(data);
        if (dataString === lastProcessedData) {
            logDebug("listenReedit: Data unchanged, skipping");
            return;
        }
        lastProcessedData = dataString;
        logDebug(`listenReedit: Received data: ${dataString}, User: ${userId}`);

        try {
            const roomSnap = await db.ref(`rooms/${roomId}`).once('value');
            const roomData = roomSnap.val() || {};
            const isDeciding = roomData.isDeciding;
            logDebug(`listenReedit: isDeciding: ${isDeciding}`);

            if (!isDeciding) {
                logDebug("listenReedit: Not in deciding phase, clearing reedit data");
                await reeditRef.remove();
                closeModalById(modalId);
                return;
            }

            if (!data) {
                logDebug("listenReedit: editConfirm is null, closing modal");
                closeModalById(modalId);
                return;
            }

            if (data.status === 'cancelled') {
                logDebug("listenReedit: Reedit process cancelled!");
                closeAllModals();
                // 找出反對者名稱（或未知用戶）
                let cancelledByName = '未知用戶';
                if (data.responses) {
                    const refusers = Object.entries(data.responses).filter(([uid, v]) => v === false);
                    if (refusers.length > 0) {
                        const [refuseId] = refusers[0];
                        const snap = await db.ref(`rooms/${roomId}/participants/${refuseId}`).once('value');
                        cancelledByName = snap.val() && snap.val().name ? snap.val().name : '未知用戶';
                    }
                }
closeAllModals();
                showModal(
                    `❅ 重新編輯流程已被 ${cancelledByName} 取消！`,
                    [{ text: '好的', class: 'btn-confirm', onClick: () => {} }],
                    'error'
                );
                // 不切頁！只顯示訊息
                return;
            }

            if (!data.active || data.status !== 'pending') {
                logDebug("listenReedit: No active reedit or not pending, cleaning up");
                await reeditRef.remove();
                closeModalById(modalId);
                return;
            }

            if (!data.initiator || !data.initiatorName) {
                logDebug("listenReedit: Invalid initiator data, ignoring");
                await reeditRef.remove();
                closeModalById(modalId);
                return;
            }

            const participantSnap = await db.ref(`rooms/${roomId}/participants`).once('value');
            const participants = participantSnap.val() || {};
            const total = Object.keys(participants).length;
            const responses = data.responses || {};
            const agreeCount = Object.values(responses).filter(v => v === true).length;
            const disagreeCount = Object.values(responses).filter(v => v === false).length;
            logDebug(`listenReedit: Total participants: ${total}, Agree: ${agreeCount}, Disagree: ${disagreeCount}, User: ${userId}`);

            // 更新票數
            await reeditRef.update({
                agreeCount: agreeCount,
                disagreeCount: disagreeCount
            });
            logDebug(`listenReedit: Updated counts - Agree: ${agreeCount}, Disagree: ${disagreeCount}`);

            const progressText = `（目前 ${agreeCount} 人同意，${disagreeCount} 人不同意）`;

            // 只要有人不同意，就彈窗，不動任何狀態，不切頁
            if (disagreeCount > 0) {
                logDebug("listenReedit: Someone disagreed, cancelling");
                await reeditRef.update({ status: 'cancelled', active: false });
                closeAllModals();
                showModal(
                    `❅ 有人不同意重新編輯（${agreeCount} 同意，${disagreeCount} 不同意），流程已取消。`,
                    [{ text: '好的', class: 'btn-confirm', onClick: () => {} }],
                    'error'
                );
                // 不切頁、不動 isDeciding
                return;
            }

            // 只有全同意，才切頁還原所有狀態
            if (agreeCount === total && total > 0) {
                logDebug("listenReedit: All agreed, returning to multiPage");
                await reeditRef.update({ status: 'completed', active: false });
                await db.ref(`rooms/${roomId}`).update({
                    isDeciding: null,
                    finalResult: null,
                    drawResult: null,
                    isDrawing: null,
                    vote: null,
                    confirm: null,
                    editConfirm: null
                });
                closeAllModals();
                showModal('✅ 所有人同意，返回編輯清單！', [
                    {
                        text: '好的',
                        class: 'btn-confirm',
                        onClick: () => {
                            const decidePage = document.getElementById('decidePage');
                            const multiPage = document.getElementById('multiPage');
                            if (!multiPage.classList.contains('active')) {
                                decidePage.classList.remove('active');
                                multiPage.classList.add('active');
                                listenVote(roomId);
                            }
                        }
                    }
                ], 'success');
                return;
            }

            // 已同意的用戶，顯示等待
            if (responses[userId] === true) {
                logDebug("listenReedit: User has agreed, showing waiting modal");
                closeAllModals();
                showWaitingModal(reeditRef, userId, `已同意，等待其他人同意中... <br>${progressText}`, modalId);
                return;
            }

            // 尚未表態，顯示同意/不同意選擇
            logDebug("listenReedit: Showing confirmation modal for user");
            closeAllModals();
            showModal(`已發起重新編輯，是否同意？<br>${progressText}`, [
                {
                    text: '同意',
                    class: 'btn-confirm',
                    onClick: async () => {
                        logDebug("listenReedit: User agrees");
                        await reeditRef.child('responses').child(userId).set(true);
                        closeAllModals();
                        showWaitingModal(reeditRef, userId, `已同意，等待其他人同意中... <br>${progressText}`, modalId);
                    }
                },
                {
                    text: '不同意',
                    class: 'btn-primary',
                    onClick: async () => {
                        logDebug("listenReedit: User disagrees");
                        await reeditRef.child('responses').child(userId).set(false);
                        closeModalById(modalId);
                        // 不做任何切頁，只彈窗！
                    }
                }
            ], modalId);

        } catch (error) {
            logDebug(`listenReedit: Error: ${error.message}`);
            showModal('重新編輯處理失敗，請稍後再試！', [
                { text: '好的', class: 'btn-confirm', onClick: () => {} }
            ], 'error');
        }
    }, 500));
}
async function getDrawData(roomRef, retry = 0) {
  const [spinListSnap, resultSnap] = await Promise.all([
    roomRef.child('drawAnimation').once('value'),
    roomRef.child('drawResult').once('value')
  ]);
  const spinList = spinListSnap.val() || [];
  const finalItem = resultSnap.val();
  // 如未抓到，最多 retry 5 次（0.12s*5=0.6秒）
  if ((!spinList.length || !finalItem) && retry < 5) {
    await new Promise(r => setTimeout(r, 120));
    return await getDrawData(roomRef, retry + 1);
  }
  return { spinList, finalItem };
}

// 這個 util 請貼在 script 內一次即可
async function getDrawData(roomRef, retry = 0) {
  const [spinListSnap, resultSnap] = await Promise.all([
    roomRef.child('drawAnimation').once('value'),
    roomRef.child('drawResult').once('value')
  ]);
  const spinList = spinListSnap.val() || [];
  const finalItem = resultSnap.val();
  if ((!spinList.length || !finalItem) && retry < 5) {
    await new Promise(r => setTimeout(r, 120));
    return await getDrawData(roomRef, retry + 1);
  }
  return { spinList, finalItem };
}

async function playDrawAnimation(roomId) {
  logDebug("playDrawAnimation: Starting draw animation");
  const roomRef = db.ref(`rooms/${roomId}`);
  try {
      const finalResultSnap = await roomRef.child('finalResult').once('value');
      if (finalResultSnap.val()) {
          showModal(`本次結果[${finalResultSnap.val()}]，請務必遵守哦！`, [
              { text: '好的', class: 'btn-confirm', onClick: () => {} }
          ], 'info');
          return;
      }

      // ★ 用 getDrawData，避免抓到空的動畫資料
      const modeSnap = await roomRef.child('decisionMode').once('value');
      const mode = modeSnap.val() || '一抽入魂';
      const { spinList, finalItem } = await getDrawData(roomRef);

      if (!spinList.length || !finalItem) {
        closeAllModals();
        showModal('清單無項目，請重新確認！', [
            { text: '好的', class: 'btn-confirm', onClick: () => {} }
        ], 'error');
        roomRef.update({ isDrawing: null, drawAnimation: null });
        return;
      }

      // 新動畫模組
      closeModalById('drawAnimation');
      const modal = document.createElement('div');
      modal.className = 'modal';
      modal.dataset.modalId = 'drawAnimation';

      const modalContent = document.createElement('div');
      modalContent.className = 'modal-content';

      // 加入動畫外框
      const frame = document.createElement('div');
      frame.className = 'lottery-animate-frame';

      const resultArea = document.createElement('div');
      resultArea.className = 'lottery-animate-text';
      resultArea.textContent = '🎰 抽籤中...';

      frame.appendChild(resultArea);
      modalContent.appendChild(frame);
      modal.appendChild(modalContent);
      document.body.appendChild(modal);

      // 柔和漸層配色輪替
      const bgColors = [
        'linear-gradient(135deg,#fff3e3 0%,#ffe8ee 100%)',
        'linear-gradient(135deg,#f0f9ff 0%,#e6ffe9 100%)',
        'linear-gradient(135deg,#ffede0 0%,#f2f3ff 100%)',
        'linear-gradient(135deg,#fff7eb 0%,#f9e7f7 100%)',
        'linear-gradient(135deg,#fffbe2 0%,#fff3e3 100%)'
      ];
      const textColors = [
        '#FF4D4F', '#3db8c4', '#FFA63C', '#FF7577', '#3CC288'
      ];

      let index = 0;
      let total = spinList.length;
      let time = 75; // 最快速度
      function animate() {
        if (index >= total) {
          // 最後一格定格大字+閃光
          resultArea.className = 'lottery-animate-text lottery-final-blue';
          frame.classList.add('lottery-final-bg-blue');
          resultArea.textContent = finalItem;

          // 讓使用者讀 2.5 秒再慢慢消失
          setTimeout(async () => {
            resultArea.style.transition = 'opacity 0.8s';
            resultArea.style.opacity = 0;
            setTimeout(async () => {
              modal.remove();

              // === ★★★★★★★★ 核心同步寫法 ★★★★★★★★ ===
              // 1. 登記「我」已經看過動畫
              await roomRef.child('drawAnimationSeen').child(userId).set(true);

              // 2. 檢查所有參與者是否都看過
              const participantsSnap = await roomRef.child('participants').once('value');
              const participants = Object.keys(participantsSnap.val() || {});
              const seenSnap = await roomRef.child('drawAnimationSeen').once('value');
              const seenUsers = Object.keys(seenSnap.val() || {});

              if (participants.every(uid => seenUsers.includes(uid))) {
                // 3. 最後一人清資料
                await roomRef.update({
                  isDrawing: null,
                  drawAnimation: null,
                  drawAnimationSeen: null,
                  drawResult: null
                });
              }
              // ★★★ 後續流程
              if (mode === '一抽入魂') {
                roomRef.update({ finalResult: finalItem });
              } else {
                initiateVoting(mode, finalItem).then(() => {
                  listenVote(roomId); // Reattach vote listener
                });
              }
            }, 800); // 淡出動畫
          }, 2500); // 給人時間看結果

          return;
        }

        // 跑馬燈效果
        resultArea.className = 'lottery-animate-text';
        resultArea.textContent = spinList[index];

        // 讓背景＆字體色彩輪流換
        const bg = bgColors[index % bgColors.length];
        const tc = textColors[index % textColors.length];
        frame.style.background = bg;
        resultArea.style.color = tc;

        // 模擬抽籤緊張感：後段變慢
        if (index > total * 0.72) time += 32;
        if (index > total * 0.87) time += 48;

        index++;
        setTimeout(() => requestAnimationFrame(animate), time);
      }

      requestAnimationFrame(animate);
  } catch (error) {
      logDebug(`playDrawAnimation: Firebase error: ${error.message}`);
      showModal('抽籤動畫失敗，請重新抽籤！', [
          { text: '好的', class: 'btn-confirm', onClick: () => {} }
      ], 'error');
      roomRef.update({ isDrawing: null, drawAnimation: null });
  }
}


async function importItems() {
    logDebug("importItems: Starting item import");
    const roomId = localStorage.getItem('currentRoomId');
    let text = prompt('請貼上要匯入的項目（JSON 或每行一項）：');
    if (!text) {
        logDebug("importItems: No input provided");
        return;
    }
    text = text.trim(); // 關鍵：去頭尾空白、空行

    let items = [];
    try {
        const parsed = JSON.parse(text);
        if (parsed && parsed.items) {
            // 不管是不是陣列，只要有 items 都抓
            if (Array.isArray(parsed.items)) {
                items = parsed.items;
            } else {
                items = [parsed.items];
            }
        } else if (Array.isArray(parsed)) {
            items = parsed;
        } else {
            throw new Error();
        }
    } catch {
        // JSON 解析失敗，當換行
        items = text.split('\n').map(s => s.trim()).filter(Boolean);
    }

    if (!items.length) {
        logDebug("importItems: No valid items to import");
        showModal('沒有可匯入的項目，請檢查格式！', [
            { text: '好的', class: 'btn-confirm', onClick: () => {} }
        ], 'error');
        return;
    }
    logDebug(`importItems: Parsed ${items.length} items`);

    const importBtn = document.querySelector('#multiPage .btn-primary[onclick="importItems()"]');
    if (importBtn) {
        importBtn.disabled = true;
        importBtn.innerHTML = '<span class="spin-animation">⏳</span> 匯入中...';
    }
    logDebug("importItems: Button disabled, importing items");

    const listRef = db.ref('rooms/' + roomId + '/list');
    const maxRetries = 3;
    let attempt = 0;

    while (attempt < maxRetries) {
        try {
            const snapshot = await listRef.once('value');
            let list = snapshot.val() || [];
            list = list.concat(items);
            await listRef.set(list);
            logDebug(`importItems: Imported ${items.length} items`);
            if (importBtn) {
                importBtn.disabled = false;
                importBtn.innerHTML = '匯入';
            }
            return;
        } catch (error) {
            attempt++;
            logDebug(`importItems: Error on attempt ${attempt}: ${error.message}`);
            if (attempt === maxRetries) {
                console.error('importItems: Firebase error after retries:', error);
                showModal('匯入項目失敗，請稍後再試！', [
                    { text: '好的', class: 'btn-confirm', onClick: () => {} }
                ], 'error');
                if (importBtn) {
                    importBtn.disabled = false;
                    importBtn.innerHTML = '匯入';
                }
            }
            await new Promise(resolve => setTimeout(resolve, 1000));
        }
    }
}


function listenVote(roomId) {
    logDebug("listenVote: Starting vote listener");
    const voteRef = db.ref(`rooms/${roomId}/vote`);
    const modalId = 'vote';
    let lastProcessedData = null;
    let voteTimeout = null;
    let modalOpened = false; // ← 標記彈窗狀態

    function clearVoteTimer() {
        if (voteTimeout) { clearTimeout(voteTimeout); voteTimeout = null; }
        // 全局倒數動畫由 showVoteCountdown 控制
    }

    voteRef.on('value', debounce(async snap => {
        const data = snap.val();
        const dataString = JSON.stringify(data);
        if (dataString === lastProcessedData) {
            logDebug("listenVote: Data unchanged, skipping");
            return;
        }
        lastProcessedData = dataString;
        logDebug(`listenVote: Received data: ${dataString}`);

        // 關掉現有倒數
        clearVoteTimer();

        try {
            const finalResultSnap = await db.ref(`rooms/${roomId}/finalResult`).once('value');
            if (finalResultSnap.val()) {
                logDebug("listenVote: Final result exists, terminating vote listener");
                await voteRef.remove();
                voteRef.off('value');
                closeModalById(modalId);
                modalOpened = false;
                hideVoteCountdown();
                return;
            }

            if (!data || !data.active || !data.item || data.status === 'cancelled') {
                logDebug("listenVote: No active vote or invalid item, removing listener and clearing vote");
                closeModalById(modalId);
                await voteRef.remove();
                voteRef.off('value');
                modalOpened = false;
                hideVoteCountdown();
                return;
            }

            const item = data.item;
            const mode = data.mode;
            const votes = data.votes || {};

            const participantSnap = await db.ref(`rooms/${roomId}/participants`).once('value');
            const participants = participantSnap.val() || {};
            const total = Object.keys(participants).length;
            const agreeCount = Object.values(votes).filter(v => v === true).length;
            const disagreeCount = Object.values(votes).filter(v => v === false).length;
            const totalVotes = Object.keys(votes).length;
            logDebug(`listenVote: Total participants: ${total}, Agree: ${agreeCount}, Disagree: ${disagreeCount}, Total votes: ${totalVotes}`);

            // 確保票數更新
            await voteRef.update({
                agreeCount: agreeCount,
                disagreeCount: disagreeCount
            });
            logDebug(`listenVote: Updated counts - Agree: ${agreeCount}, Disagree: ${disagreeCount}`);

            const progressText = `（目前 ${agreeCount} 人同意，${disagreeCount} 人不同意）`;
            // 🔹 加這段確保同步票數顯示
const progressEl = document.getElementById('vote-progress-text');
if (progressEl) {
    progressEl.textContent = progressText;
}

            // ======= 投票 modal & 全域倒數條 =======
            if (!(userId in votes)) {
                logDebug(`listenVote: User ${userId} has not voted, showing vote modal`);
                if (!modalOpened) {
                    closeAllModals();
                    showModal(
                        `是否同意將「${item}」作為最終結果？<br><span id="vote-progress-text">${progressText}</span>`,
                        [
                            {
                                text: '同意',
                                class: 'btn-confirm',
                                onClick: async () => {
                                    clearVoteTimer();
                                    closeModalById(modalId);
                                    modalOpened = false;
                                    hideVoteCountdown();
                                    await voteRef.child('votes/' + userId).set(true);
                                    showWaitingModal(voteRef, userId, `已同意，等待其他人投票中... <br>${progressText}`, modalId);
                                    lastProcessedData = null;
                                }
                            },
                            {
                                text: '不同意',
                                class: 'btn-primary',
                                onClick: async () => {
                                    clearVoteTimer();
                                    closeAllModals();
                                    modalOpened = false;
                                    hideVoteCountdown();
                                    await voteRef.child('votes/' + userId).set(false);
                                    lastProcessedData = null;
                                }
                            }
                        ],
                        modalId
                    );
                    modalOpened = true;

                    // 全域倒數動畫（25秒）
                    showVoteCountdown(25);

                    // 25秒後自動同意
                    voteTimeout = setTimeout(() => {
                        clearVoteTimer();
                        closeModalById(modalId);
                        modalOpened = false;
                        hideVoteCountdown();
                        voteRef.child('votes/' + userId).set(true);
                        showWaitingModal(voteRef, userId, `（已自動同意）等待其他人投票中... <br>${progressText}`, modalId);
                        lastProcessedData = null;
                    }, 25000);
                } else {
                    // 只更新投票進度文字
                    const progressEl = document.getElementById('vote-progress-text');
                    if (progressEl) progressEl.textContent = progressText;
                }
            } else {
                clearVoteTimer();
                modalOpened = false;
                hideVoteCountdown();
                logDebug(`listenVote: User ${userId} has voted, showing waiting modal`);
                showWaitingModal(voteRef, userId, `已投票，等待其他人投票中... <br>${progressText}`, modalId);
            }

            // 判斷票數
            if (mode === '共識決') {
                if (totalVotes === total) {
                    if (agreeCount === total) {
                        await db.ref(`rooms/${roomId}`).update({
                            finalResult: item,
                            isDrawing: null
                        });
                        closeAllModals();
                        voteRef.off('value');
                        modalOpened = false;
                        hideVoteCountdown();
                    } else {
                        closeAllModals();
                        modalOpened = false;
                        hideVoteCountdown();
                        showModal(
                            `❌ 未達成條件<br>（${agreeCount} 同意，${disagreeCount} 不同意），請再抽一次！`,
                            [{
                                text: '好的',
                                class: 'btn-confirm',
                                onClick: async () => {
                                    await db.ref(`rooms/${roomId}`).update({
                                        vote: null,
                                        isDrawing: null,
                                        drawAnimation: null,
                                        drawResult: null
                                    });
                                    safeEnableDrawBtn();
                                }
                            }],
                            'error'
                        );
                    }
                }
            } else if (mode === '多數決') {
                if (totalVotes === total) {
                    if (agreeCount > total / 2) {
                        await db.ref(`rooms/${roomId}`).update({
                            finalResult: item,
                            isDrawing: null
                        });
                        closeAllModals();
                        voteRef.off('value');
                        modalOpened = false;
                        hideVoteCountdown();
                    } else {
                        closeAllModals();
                        modalOpened = false;
                        hideVoteCountdown();
                        showModal(
                            `❌ 未達成條件（${agreeCount} 同意，${disagreeCount} 不同意），請再抽一次！`,
                            [{
                                text: '好的',
                                class: 'btn-confirm',
                                onClick: async () => {
                                    await db.ref(`rooms/${roomId}`).update({
                                        vote: null,
                                        isDrawing: null,
                                        drawAnimation: null,
                                        drawResult: null
                                    });
                                    const drawBtn = document.querySelector('#decidePage .btn-draw');
                                    if (drawBtn) drawBtn.disabled = false;
                                }
                            }],
                            'error'
                        );
                    }
                }
            }

        } catch (error) {
            logDebug(`listenVote: Error: ${error.message}`);
            hideVoteCountdown();
            showModal('投票處理失敗，請稍後再試！', [
                { text: '好的', class: 'btn-confirm', onClick: () => {} }
            ], 'error');
        }
    }, 500));
}


function leaveRoom() {
    logDebug && logDebug("leaveRoom: Initiating room exit");
    // 判斷目前是不是 setupPage
    if (document.getElementById('setupPage').classList.contains('active')) {
        window.location.href = 'index.html';
        return;
    }
    showModal('確定要離開此房間嗎？', [
        {
            text: '確定',
            class: 'btn-confirm',
            onClick: () => {
                logDebug && logDebug("leaveRoom: Confirm leave clicked");
                const roomId = localStorage.getItem('currentRoomId');
                const userId = localStorage.getItem(`currentUserId_${roomId}`);
                const roomRef = db.ref(`rooms/${roomId}`);

                roomRef.child('participants').transaction(participants => {
                    if (!participants) return;
                    delete participants[userId];
                    const participantCount = Object.keys(participants).length;
                    roomRef.child('participants/' + userId).remove();

                    if (participantCount === 0) {
                        roomRef.update({
                            drawResult: null,
                            finalResult: null,
                            isDrawing: null,
                            vote: null,
                            confirm: null,
                            editConfirm: null
                        });
                    }
                    localStorage.removeItem('currentRoomId');
                    localStorage.removeItem(`currentUserId_${roomId}`);
                    window.location.href = 'index.html';
                });
            }
        },
        {
            text: '取消',
            class: 'btn-primary',
            onClick: () => {
                logDebug && logDebug("leaveRoom: Cancel leave clicked");
            }
        }
    ], 'leave');
}

function generateVerificationCode() {
    const digits = Math.floor(Math.random() * 90 + 10).toString();
    const letters = String.fromCharCode(
        Math.floor(Math.random() * 26) + 97,
        Math.floor(Math.random() * 26) + 97
    );
    const code = digits + letters;
    logDebug(`generateVerificationCode: Generated code ${code}`);
    return code;
}

window.addEventListener('DOMContentLoaded', function() {
    // 取得網址參數
    const params = new URLSearchParams(window.location.search);
    const room = params.get('room');
    const code = params.get('code');
    // 如果有就自動填入 input
    if (room) document.getElementById('roomNameInput').value = decodeURIComponent(room);
    if (code) document.getElementById('verificationCodeInput').value = decodeURIComponent(code);
});

// 頁面載入後執行
window.addEventListener('DOMContentLoaded', function() {
  document.querySelectorAll('.item-container').forEach(function(box) {
    box.addEventListener('touchstart', function(e) {
      // 記住觸控開始時的scrollTop
      box._startY = e.touches[0].clientY;
      box._startScroll = box.scrollTop;
    }, {passive: false});

    box.addEventListener('touchmove', function(e) {
      const scrollTop = box.scrollTop;
      const scrollHeight = box.scrollHeight;
      const offsetHeight = box.offsetHeight;
      const atTop = scrollTop === 0;
      const atBottom = scrollTop + offsetHeight >= scrollHeight - 1;
      const moveY = e.touches[0].clientY - box._startY;
      // 向下滑且在頂部、或向上滑且在底部 => 阻止
      if ((atTop && moveY > 0) || (atBottom && moveY < 0)) {
        e.preventDefault();
      }
    }, {passive: false});
  });
});
function chooseImportType() {
  showModal('請選擇匯入方式', [
    {
      text: '📝貼上',
      class: 'btn-primary',
      onClick: () => importItems()
    },
    {
      text: '📂本地',
      class: 'btn-primary',
      onClick: () => showLocalListForImport()
    },
    {
      text: '⨉', 
      class: 'btn-confirm',
      onClick: () => {}
    }
  ], 'importType');
}
function showLocalListForImport() {
  const lists = [];
  for (let i = 0; i < localStorage.length; i++) {
    const key = localStorage.key(i);

    // 你可以加自己的 key 條件，例如 key === 'memoryData' 或其它
    if (key.startsWith('chooseHelperList_') || key === 'memoryData') {
      try {
        const data = JSON.parse(localStorage.getItem(key));

        // 格式1：有 items 陣列
        if (data && Array.isArray(data.items)) {
          lists.push({
            key,
            name: data.name || key,
            items: data.items
          });
        } 
        // 格式2：key-value map，每個 key 一個 array
        else if (data && typeof data === 'object') {
          for (const k in data) {
            if (Array.isArray(data[k])) {
              lists.push({
                key: key + ':' + k, // key:memoryData:晚餐吃什麼
                name: k,
                items: data[k]
              });
            }
          }
        }
      } catch (e) {}
    }
  }

  if (lists.length === 0) {
    showModal('找不到任何本地清單！', [
      { text: '好的', class: 'btn-confirm', onClick: () => {} }
    ], 'error');
    return;
  }

  // 彈窗讓用戶選
  const content = `<div style="max-height:320px;overflow:auto;text-align:left;">
    ${lists.map((list, idx) => `
      <div style="margin-bottom:8px;padding:8px 0;">
        <b>${list.name}</b>
        <span style="color:#888;font-size:0.93em;">（${list.items.length} 項）</span>
        <button class="btn-primary" style="margin-left:12px;padding:2px 14px;font-size:14px;" onclick="window._importLocalList('${list.key}')">匯入</button>
      </div>
    `).join('')}
  </div>`;

  showModal(content, [
    { text: '取消', class: 'btn-primary', onClick: () => {} }
  ], 'localListImport');

  // 臨時掛 window，做 key-value 取出
  window._importLocalList = function(fullKey) {
    let key = fullKey, subkey = null;
    if (fullKey.includes(':')) {
      [key, subkey] = fullKey.split(':');
    }
    try {
      const data = JSON.parse(localStorage.getItem(key));
      let items = [];
      if (subkey) {
        items = data[subkey];
      } else {
        items = data.items;
      }
      if (Array.isArray(items) && items.length > 0) {
        importItemsFromArray(items);
      } else {
        showModal('清單格式錯誤，無法匯入', [
          { text: '好的', class: 'btn-confirm', onClick: () => {} }
        ], 'error');
      }
    } catch {
      showModal('匯入失敗', [
        { text: '好的', class: 'btn-confirm', onClick: () => {} }
      ], 'error');
    }
    closeAllModals();
  }
}

async function importItemsFromArray(items) {
    logDebug("importItemsFromArray: Importing array items");
    const roomId = localStorage.getItem('currentRoomId');
    if (!Array.isArray(items) || items.length === 0) {
      showModal('沒有可匯入的項目！', [
        { text: '好的', class: 'btn-confirm', onClick: () => {} }
      ], 'error');
      return;
    }
    const listRef = db.ref('rooms/' + roomId + '/list');
    const importBtn = document.querySelector('#multiPage .btn-primary[onclick="chooseImportType()"]');
    if (importBtn) {
      importBtn.disabled = true;
      importBtn.innerHTML = '<span class="spin-animation">⏳</span> 匯入中...';
    }
    let attempt = 0, maxRetries = 3;
    while (attempt < maxRetries) {
        try {
            const snapshot = await listRef.once('value');
            let list = snapshot.val() || [];
            list = list.concat(items);
            await listRef.set(list);
            logDebug(`importItemsFromArray: Imported ${items.length} items`);
            if (importBtn) {
              importBtn.disabled = false;
              importBtn.innerHTML = '匯入';
            }
            showModal('已匯入本地清單', [
              { text: '好的', class: 'btn-confirm', onClick: () => {} }
            ], 'success');
            return;
        } catch (error) {
            attempt++;
            logDebug(`importItemsFromArray: Error on attempt ${attempt}: ${error.message}`);
            if (attempt === maxRetries) {
                showModal('匯入項目失敗，請稍後再試！', [
                    { text: '好的', class: 'btn-confirm', onClick: () => {} }
                ], 'error');
                if (importBtn) {
                  importBtn.disabled = false;
                  importBtn.innerHTML = '匯入';
                }
            }
            await new Promise(resolve => setTimeout(resolve, 1000));
        }
    }
}

function showCertificate(result) {
  // 先隱藏決定方式
  document.getElementById('decideModeDisplay').style.display = 'none';
  // 取得日期
  const date = new Date();
  const dateStr = `${date.getFullYear()}年${date.getMonth()+1}月${date.getDate()}日`;
  const roomId = localStorage.getItem('currentRoomId');
  db.ref(`rooms/${roomId}/participants`).once('value').then(snap => {
    const membersArr = Object.values(snap.val() || {}).map(u => u.name);
    db.ref(`rooms/${roomId}/decisionMode`).once('value').then(modeSnap => {
      const mode = modeSnap.val() || '一抽入魂';
      // 填寫所有資料
      renderCertificateCanvas({
        title: '抽籤決議證明書',
        date: dateStr,
        membersArr,
        mode,
        result,
        statement: [
          "【共同聲明】",
          "本次抽籤結果即為最終決議，",
          "參與者皆承諾共同遵守，",
          "不得任意更改或拒絕執行。"
        ]
      });
    });
  });
}

function renderCertificateCanvas(data) {
  const targetDiv = document.getElementById('resultArea');
  targetDiv.innerHTML = '';

  // 獎狀底圖尺寸
  const W = 640, H = 452;
  const canvas = document.createElement('canvas');
  canvas.width = W;
  canvas.height = H;
  const ctx = canvas.getContext('2d');

  // 字體
  const fontFamily = '"標楷體","DFKai-SB","BiauKai","Noto Serif TC",serif';

  // 區塊配置
  const titleY = 62;
  const infoStartY = 110;
  const infoGapY = 37;
  const membersBlockY = 147;
  const resultBlockY = 235;
  const statementBlockY = 340; // 共同聲明區再往下拉

  // 背景圖
  const img = new Image();
  img.crossOrigin = 'anonymous';
  img.src = 'https://cdn.jsdelivr.net/gh/a355226/choosehelper@main/paper.png';

  img.onload = function () {
    ctx.drawImage(img, 0, 0, W, H);

    // 1. 抬頭
    ctx.font = `bold 32px ${fontFamily}`;
    ctx.fillStyle = '#8a3605';
    ctx.textAlign = 'center';
    ctx.shadowColor = "#ffeedd";
    ctx.shadowBlur = 8;
    ctx.fillText(data.title, W / 2, titleY);
    ctx.shadowBlur = 0;

    // 2. 日期
    ctx.font = `21px ${fontFamily}`;
    ctx.fillStyle = '#111';
    ctx.textAlign = 'left';
    ctx.fillText(`🗓️ 日期：${data.date}`, 60, infoStartY);

    // 3. 決定方式
    ctx.font = `21px ${fontFamily}`;
    ctx.fillStyle = '#111';
    ctx.textAlign = 'right';
    ctx.fillText(`抽籤方式：${data.mode}`, W - 60, infoStartY);

    // 4. 參與者區塊（自動行分割＆自動縮字）
    ctx.textAlign = 'center';
    ctx.fillStyle = '#111';
    let membersText = `本次參與者：${data.membersArr.join('、')}`;
    let memberFontSize = 23, minFont = 13;
    // 參與者長度自動縮字
    ctx.font = `${memberFontSize}px ${fontFamily}`;
    while (memberFontSize > minFont && ctx.measureText(membersText).width > W - 80) {
      memberFontSize--;
      ctx.font = `${memberFontSize}px ${fontFamily}`;
    }
    // 多行分割
    let lines = [];
    let maxLineW = W - 80;
    let names = data.membersArr;
    ctx.font = `${memberFontSize}px ${fontFamily}`;
    let current = "本次參與者：";
    for (let i = 0; i < names.length; i++) {
      let next = (current.endsWith('：') ? current : current + '、') + names[i];
      if (ctx.measureText(next).width > maxLineW && current !== "本次參與者：") {
        lines.push(current);
        current = names[i];
      } else {
        current = next;
      }
    }
    lines.push(current);

    for (let i = 0; i < lines.length; i++) {
      ctx.fillText(lines[i], W / 2, membersBlockY + i * memberFontSize * 1.24);
    }

    // 5. 決議結果（紅色大字，線條細，清晰！）
    ctx.save();
    // 主標
    ctx.font = `bold 32px ${fontFamily}`;
    ctx.textAlign = 'center';
    ctx.fillStyle = "#b15906";
    ctx.fillText(`🎉 本次決議結果：`, W / 2, resultBlockY);

    // 決議結果大紅字（微白光，無粗描邊）
    ctx.font = `bold 54px ${fontFamily}`;
    ctx.shadowColor = "#fff";
    ctx.shadowBlur = 5;
    ctx.fillStyle = "#cf2d3a";
    ctx.fillText(data.result, W / 2, resultBlockY + 56);
    ctx.shadowBlur = 0;
    ctx.restore();

    // 6. 共同聲明（縮小，不搶焦）
    ctx.font = `17px ${fontFamily}`;
    ctx.fillStyle = '#555';
    ctx.textAlign = 'center';
    let statementGapY = 22;
    for (let i = 0; i < data.statement.length; i++) {
      ctx.fillText(data.statement[i], W / 2, statementBlockY + i * statementGapY);
    }
  };

  targetDiv.appendChild(canvas);
}

function showVoteCountdown(duration = 25) {
  let remain = duration;
  // 先清掉舊的
  let old = document.getElementById('global-vote-countdown');
  if (old) old.remove();

  // 新增倒數條
  let el = document.createElement('div');
  el.id = 'global-vote-countdown';
  el.style = `
    position:fixed;top:0;left:0;width:100vw;z-index:99999;
    background:rgba(255,255,255,0.95);text-align:center;
    font-size:22px;padding:13px 0 6px 0;box-shadow:0 3px 12px #aaa;
    transition:opacity 0.3s;
  `;
  el.innerHTML = `
    <span style="font-weight:bold;color:#cf2d3a;">⏳ <span id="vote-countdown-num">${remain}</span> 秒</span>
    <div style="margin:4px auto 0;width:92%;background:linear-gradient(90deg,#FF7577 70%,#FFB85C 100%);border-radius:8px;height:13px;overflow:hidden;">
      <div id="vote-countdown-bar" style="height:100%;background:#fff7bb;transition:width 0.2s;width:100%;"></div>
    </div>
  `;
  document.body.appendChild(el);

  // 動畫
  let interval = setInterval(() => {
    remain--;
    let n = document.getElementById('vote-countdown-num');
    let bar = document.getElementById('vote-countdown-bar');
    if (n) n.textContent = remain;
    if (bar) bar.style.width = (remain/duration*100) + '%';
    if (remain <= 0) {
      clearInterval(interval);
      hideVoteCountdown();
    }
  }, 1000);

  // 關掉用
  window._voteCountdownInterval = interval;
}
function hideVoteCountdown() {
  let el = document.getElementById('global-vote-countdown');
  if (el) {
    el.style.opacity = 0;
    setTimeout(() => el.remove(), 350);
  }
  if (window._voteCountdownInterval) {
    clearInterval(window._voteCountdownInterval);
    window._voteCountdownInterval = null;
  }
}


</script>
</head>
<body>
<h1><img src="https://cdn.jsdelivr.net/gh/a355226/choosehelper@main/icon.png" alt="icon" width="32"> 決策小幫手</h1>
<div class="page active" id="setupPage">
<div class="exit-btn" onclick="leaveRoom()" title="離開"></div>
  <div class="header-row" style="justify-content: flex-end;">
  </div>
  <h2>🏠 建立 / 加入房間</h2>
  <input type="text" id="roomNameInput" placeholder="房間名稱" />
  <input type="text" id="verificationCodeInput" placeholder="驗證碼（新房間免填）" />
  <input type="text" id="userNameInput" placeholder="你的名稱" />
  <button class="btn-primary" onclick="createRoom()" style="margin-top: 26px;">建立 / 加入</button>

</div>
<div class="page" id="multiPage">
<div class="exit-btn" onclick="leaveRoom()" title="離開"></div>
  <div class="header-row" style="display: flex; justify-content: space-between; align-items: center;">
  <div>
    <span id="roomNameDisplay" style="font-weight:bold; font-size:1.2em; letter-spacing:1px;"></span>
    <span id="roomCodeDisplay" style="color:#888; font-size:0.95em; margin-left: 5px;"></span>
  </div>
  <button class="btn-primary" style="padding:6px 14px; font-size:15px; background:#2894FF;" onclick="shareRoom()">分享</button>

</div>

  <div><strong id="participantCount">參與者(0人)： </strong>
    <div id="participantContainer" class="item-container"></div>
  </div>
  <div style="margin-top: 10px; text-align:left;">
    <button class="btn-primary" onclick="chooseDecisionMode()">決定方式</button>
    <span id="selectedMode" class="selected-mode-tag"></span>

  </div>
  <div style="margin-top: 20px;"><strong>📃 清單項目：</strong>
    <div id="listContainer" class="item-container"></div>
    <input type="text" id="itemInput" placeholder="輸入項目" onkeypress="if(event.key==='Enter') addItem();" />
    <div style="display:flex; gap:6px; margin-top:4px;">
      <button class="btn-primary" onclick="addItem()">新增項目</button>
      <button class="btn-primary" onclick="chooseImportType()">匯入</button>

    </div>
    <div style="margin-top:30px;">
      <button class="btn-confirm-red" onclick="requestConfirmation()">我同意此清單</button>
    </div>
  </div>
  <div id="multiDebugBox" class="debug-box"></div>
</div>
<div class="page" id="decidePage">
<div class="exit-btn" onclick="leaveRoom()" title="離開"></div>

  <div class="header-row" style="align-items:flex-start; justify-content:space-between;">
  <div style="display:flex; flex-direction:column; align-items:flex-start;">
<div style="display:inline-flex; align-items:center;">
  <span id="decideRoomNameDisplay" style="font-weight:bold; font-size:1.25em;"></span>
  <span id="decideRoomCodeDisplay" style="color:#888; font-size:1em; margin-left:8px;"></span>
</div>


    <button class="btn-primary" style="padding:3px 10px; font-size:12px; margin-top:8px; border-radius:8px;" onclick="requestReedit()">← 重新編輯</button>

  </div>
  <div>
  </div>
</div>

  <div>
    <strong id="decideParticipantCount">參與者(0人)：</strong>
    <div id="decideParticipantContainer" class="item-container"></div>
  </div>
  <div style="text-align:center; margin-top: 30px;">
    <button class="btn-draw" onclick="startDraw()">🎲 開始抽籤</button>
<div id="decideModeDisplay"></div>
    <div id="resultArea" style="font-size: 2em; margin-top: 20px;"></div>
  </div>
  <div id="decideDebugBox" class="debug-box"></div>
</div>
</body>
</html>




