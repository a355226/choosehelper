<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8">
<title>ÈÅ∏ÊìáÂ∞èÂπ´Êâã - Âª∫Á´ãÊàøÈñì</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<link rel="icon" type="image/png" sizes="32x32" href="icon.png">
<link rel="apple-touch-icon" sizes="180x180" href="icon.png">
<link rel="manifest" href="manifest.json">
<style>
  body {
    font-family: "Segoe UI", sans-serif;
    background-color: #f0f9ff;
    margin: 0;
    padding: 0;
    color: #2c3e50;
  }
  h1 {
    text-align: center;
    padding: 20px 10px;
    margin: 0;
    font-weight: 600;
    font-size: 1.6em;
  }
  .page {
    display: none;
    padding: 20px;
    max-width: 600px;
    margin: auto;
  }
  .page.active {
    display: block;
  }
  .btn-primary, .btn-confirm {
    border: none;
    border-radius: 10px;
    padding: 10px 18px;
    font-size: 15px;
    font-weight: 600;
    cursor: pointer;
    box-shadow: 0 3px 6px rgba(0,0,0,0.1);
    transition: background-color 0.2s, transform 0.1s;
  }
  .btn-primary {
    background-color: #3db8c4;
    color: white;
  }
  .btn-primary:hover {
    background-color: #35a4af;
  }
  .btn-confirm {
    background-color: #2c3e50;
    color: white;
  }
  .btn-confirm:hover {
    background-color: #1e2a38;
  }
  .btn-confirm-red {
    background-color: #e74c3c;
    color: white;
    border: none;
    border-radius: 8px;
    padding: 10px 16px;
    font-size: 16px;
    font-weight: bold;
    cursor: pointer;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    transition: all 0.2s ease;
  }
  .btn-confirm-red:hover {
    background-color: #c0392b;
  }
  input {
    padding: 10px;
    font-size: 16px;
    margin: 10px 0;
    border-radius: 8px;
    border: 1px solid #ccc;
    width: 100%;
    box-sizing: border-box;
    transition: border 0.2s, box-shadow 0.2s;
  }
  input:focus {
    border-color: #3db8c4;
    box-shadow: 0 0 5px rgba(61, 184, 196, 0.5);
    outline: none;
  }
  .item-container {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    max-height: calc(1.8em * 3 + 20px);
    overflow-y: auto;
    padding: 6px;
    background: #ffffffcc;
    border-radius: 10px;
  }
  .item-box {
    background: #e0f4ff;
    border-radius: 16px;
    padding: 6px 12px;
    font-size: 14px;
    white-space: nowrap;
    max-width: 150px;
    overflow: hidden;
    text-overflow: ellipsis;
    display: flex;
    align-items: center;
  }
  .remove-btn {
    background: none;
    border: none;
    color: #c0392b;
    font-size: 16px;
    cursor: pointer;
    margin-left: 6px;
    flex-shrink: 0;
  }
  .header-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    flex-wrap: wrap;
    gap: 10px;
    margin-bottom: 12px;
  }
  .modal {
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(0,0,0,0.65);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 9999;
  }
  .modal-content {
    background: white;
    max-width: 90%;
    max-height: 80%;
    overflow-y: auto;
    padding: 20px;
    border-radius: 12px;
    text-align: center;
  }
  .modal-content button {
    margin: 6px 10px;
  }
  .hidden { display: none; }
  @keyframes spin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
  }
  .spin-animation {
      animation: spin 1s linear infinite;
      display: inline-block;
  }
  .result-final {
    font-size: 1.8em;
    color: #3db8c4;
    font-weight: bold;
    animation: pulse 1s infinite;
  }
  @keyframes pulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.1); }
    100% { transform: scale(1); }
  }
  .debug-box {
    position: fixed;
    bottom: 10px;
    right: 10px;
    width: 300px;
    height: 150px;
    background: #f0f0f0;
    border: 1px solid #000;
    overflow-y: auto;
    padding: 10px;
    font-size: 12px;
    z-index: 10000;
    font-family: monospace;
  }
</style>
<script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>
<script>
const firebaseConfig = {
    apiKey: "AIzaSyBUbKgC4P7wGFQqZZmgJU890qOe_4yC9kA",
    authDomain: "choosehel.firebaseapp.com",
    databaseURL: "https://choosehel-default-rtdb.asia-southeast1.firebasedatabase.app",
    projectId: "choosehel",
    storageBucket: "choosehel.appspot.com",
    messagingSenderId: "116763876894",
    appId: "1:116763876894:web:1662b36ef2fa815863d80f"
};
firebase.initializeApp(firebaseConfig);
const db = firebase.database();

let userId;
let hasShownReeditSuccess = false;
let hasShownConfirmModal = false;
let hasShownReeditModal = false;
let lastConfirmInitiator = null;
let lastReeditInitiator = null;

// Debug function to log messages to the appropriate debug box
function logDebug(message) {
    const activePage = document.querySelector('.page.active');
    let debugBox;
    if (activePage.id === 'multiPage') {
        debugBox = document.getElementById('multiDebugBox');
    } else if (activePage.id === 'decidePage') {
        debugBox = document.getElementById('decideDebugBox');
    }
    if (debugBox) {
        debugBox.innerHTML += `<p>${new Date().toLocaleTimeString()} - ${message}</p>`;
        debugBox.scrollTop = debugBox.scrollHeight;
    }
}

// Debounce function to reduce repeated Firebase triggers
function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
}

async function createRoom() {
    logDebug("createRoom: Starting room creation");
    const roomName = document.getElementById('roomNameInput').value.trim();
    const verificationCodeInput = document.getElementById('verificationCodeInput').value.trim();
    const userName = document.getElementById('userNameInput').value.trim();

    if (!roomName || !userName) {
        logDebug("createRoom: Missing roomName or userName");
        showModal('Ë´ãËº∏ÂÖ•ÊàøÈñìÂêçÁ®±Âíå‰Ω†ÁöÑÂêçÁ®±', [
            { text: 'Â•ΩÁöÑ', class: 'btn-confirm', onClick: () => {} }
        ], 'error');
        return;
    }

    let verificationCode = verificationCodeInput || generateVerificationCode();
    const roomIdRaw = `${roomName}-${verificationCode}`;
    const roomId = encodeURIComponent(roomIdRaw);
    const createBtn = document.querySelector('#setupPage .btn-primary');
    createBtn.disabled = true;
    createBtn.innerHTML = '<span class="spin-animation">‚è≥</span> Âª∫Á´ã‰∏≠...';
    logDebug(`createRoom: Attempting to create/join room ${roomId}`);

    userId = 'user_' + Math.random().toString(36).substr(2, 9);
    localStorage.setItem(`currentUserId_${roomId}`, userId);
    localStorage.setItem('currentRoomId', roomId);
    logDebug(`createRoom: Generated userId ${userId} for user ${userName} in room ${roomId}`);

    const roomRef = db.ref('rooms/' + roomId);
    const maxRetries = 3;
    let attempt = 0;

    while (attempt < maxRetries) {
        try {
            const snapshot = await roomRef.child('participants').once('value');
            const participants = snapshot.val() || {};
            logDebug(`createRoom: Found ${Object.keys(participants).length} participants`);
            if (Object.keys(participants).length === 0) {
                await roomRef.update({
                    finalResult: null,
                    drawResult: null,
                    isDrawing: null,
                    vote: null,
                    confirm: null,
                    editConfirm: null
                });
                logDebug("createRoom: Initialized empty room");
            }
            await roomRef.update({
                name: roomName,
                code: verificationCode,
                creator: userName                
            });
            const participantRef = roomRef.child('participants/' + userId);
            await participantRef.set({ name: userName });
            participantRef.onDisconnect().remove();
            logDebug(`createRoom: Added user ${userId} (${userName})`);

            document.getElementById('setupPage').classList.remove('active');
            document.getElementById('multiPage').classList.add('active');
            document.getElementById('roomNameDisplay').textContent = `ÊàøÈñìÔºö${roomName} (È©óË≠âÁ¢ºÔºö${verificationCode})`;
            logDebug("createRoom: Switched to multiPage");

            loadRoomData(roomId);
            listenConfirmation(roomId);
            listenVote(roomId);
            listenReedit(roomId); // Á¢∫‰øùÈáçÊñ∞Á∑®ËºØÁõ£ËÅΩÂú®ÊàøÈñìÂâµÂª∫ÊôÇÂïüÂãï
            createBtn.disabled = false;
            createBtn.innerHTML = 'Âª∫Á´ã / Âä†ÂÖ•';
            logDebug("createRoom: Successfully created/joined room");
            return;
        } catch (error) {
            attempt++;
            logDebug(`createRoom: Error on attempt ${attempt}: ${error.message}`);
            if (attempt === maxRetries) {
                console.error('createRoom: Firebase error after retries:', error);
                showModal('ÊàøÈñìÂª∫Á´ãÂ§±ÊïóÔºåË´ãÁ®çÂæåÂÜçË©¶ÔºÅ', [
                    { text: 'Â•ΩÁöÑ', class: 'btn-confirm', onClick: () => {} }
                ], 'error');
                createBtn.disabled = false;
                createBtn.innerHTML = 'Âª∫Á´ã / Âä†ÂÖ•';
            }
            await new Promise(resolve => setTimeout(resolve, 1000));
        }
    }
}

function showModal(content, buttons, modalId = 'generic') {
    if (document.querySelector(`.modal[data-modalId="${modalId}"]`)) {
        logDebug(`showModal: Modal ${modalId} already exists, skipping`);
        return;
    }
    closeModalById(modalId);
    const modal = document.createElement('div');
    modal.className = 'modal';
    modal.dataset.modalId = modalId;
    const modalContent = document.createElement('div');
    modalContent.className = 'modal-content';
    modalContent.innerHTML = `<p style="font-size:18px;">${content}</p>`;
    buttons.forEach(btn => {
        const button = document.createElement('button');
        button.className = btn.class || 'btn-primary';
        button.textContent = btn.text;
        button.onclick = () => {
            logDebug(`showModal: Button clicked - ${btn.text} for modal ${modalId}`);
            modal.remove();
            btn.onClick();
        };
        modalContent.appendChild(button);
    });
    modal.appendChild(modalContent);
    document.body.appendChild(modal);
    logDebug(`showModal: Displayed modal ${modalId} with content: ${content}`);
}

function closeModalById(modalId) {
    const modal = document.querySelector(`.modal[data-modalId="${modalId}"]`);
    if (modal) {
        modal.remove();
        logDebug(`closeModalById: Closed modal ${modalId}`);
    }
}

function closeAllModals() {
    document.querySelectorAll('.modal').forEach(modal => {
        logDebug(`closeAllModals: Closing modal ${modal.dataset.modalId}`);
        modal.remove();
    });
}

function loadRoomData(roomId) {
    logDebug("loadRoomData: Loading room data");
    const roomRef = db.ref('rooms/' + roomId);
    const participantContainer = document.getElementById('participantContainer');
    const listContainer = document.getElementById('listContainer');

    roomRef.child('isDrawing').on('value', snap => {
        const isDrawing = snap.val();
        logDebug(`loadRoomData: isDrawing changed to ${isDrawing}`);
        if (isDrawing) {
            playDrawAnimation(roomId);
        }
    });

    roomRef.child('finalResult').on('value', snap => {
        const result = snap.val();
        logDebug(`loadRoomData: finalResult changed to ${result}`);
        if (result) {
            if (!document.getElementById('decidePage').classList.contains('active')) {
                document.getElementById('multiPage').classList.remove('active');
                document.getElementById('decidePage').classList.add('active');
                logDebug("loadRoomData: Switched to decidePage due to finalResult");
            }
            setTimeout(() => {
                showFinalResult(result);
            }, 150);
        }
    });

    roomRef.child('participants').on('value', snapshot => {
        const data = snapshot.val() || {};
        logDebug(`loadRoomData: Participants updated, count: ${Object.keys(data).length}`);
        participantContainer.innerHTML = '';
        const participantCountDisplay = document.getElementById('participantCount');
        if (participantCountDisplay) {
            participantCountDisplay.textContent = `ÂèÉËàáËÄÖ(${Object.keys(data).length}‰∫∫)Ôºö`;
        }

        const decideParticipantContainer = document.getElementById('decideParticipantContainer');
        const decideParticipantCountDisplay = document.getElementById('decideParticipantCount');
        if (decideParticipantContainer) decideParticipantContainer.innerHTML = '';
        if (decideParticipantCountDisplay) {
            decideParticipantCountDisplay.textContent = `ÂèÉËàáËÄÖ(${Object.keys(data).length}‰∫∫)Ôºö`;
        }

        Object.values(data).forEach(p => {
            const div = document.createElement('div');
            div.className = 'item-box';
            div.textContent = p.name;
            participantContainer.appendChild(div);

            if (decideParticipantContainer) {
                const divClone = div.cloneNode(true);
                decideParticipantContainer.appendChild(divClone);
            }
        });
    });

    roomRef.child('list').on('value', snapshot => {
        const items = snapshot.val() || [];
        logDebug(`loadRoomData: List updated, items: ${items.length}`);
        listContainer.innerHTML = '';
        items.forEach((item, index) => {
            const div = document.createElement('div');
            div.className = 'item-box';
            const span = document.createElement('span');
            span.textContent = item;
            const btn = document.createElement('button');
            btn.textContent = '‚úï';
            btn.className = 'remove-btn';
            btn.onclick = () => removeItem(index);
            div.appendChild(span);
            div.appendChild(btn);
            listContainer.appendChild(div);
        });
    });

    roomRef.child('decisionMode').on('value', snapshot => {
        const mode = snapshot.val() || '';
        logDebug(`loadRoomData: Decision mode changed to ${mode}`);
        document.getElementById('selectedMode').textContent = mode ? `Â∑≤ÈÅ∏ÊìáÔºö${mode}` : '';
        const decideModeDisplay = document.getElementById('decideModeDisplay');
        if (decideModeDisplay) decideModeDisplay.textContent = mode ? `Ê±∫ÂÆöÊñπÂºèÔºö${mode}` : '';
    });

    roomRef.child('name').once('value').then(nameSnap => {
        const roomName = nameSnap.val() || '';
        roomRef.child('code').once('value').then(codeSnap => {
            const verificationCode = codeSnap.val() || '';
            const decideRoomNameDisplay = document.getElementById('decideRoomNameDisplay');
            if (decideRoomNameDisplay) {
                decideRoomNameDisplay.textContent = `ÊàøÈñìÔºö${roomName} (È©óË≠âÁ¢ºÔºö${verificationCode})`;
                logDebug(`loadRoomData: Room name set to ${roomName}, code: ${verificationCode}`);
            }
        });
    });

roomRef.child('isDeciding').on('value', snap => {
    const isDeciding = snap.val();
    logDebug(`loadRoomData: isDeciding changed to ${isDeciding}`);
    const decidePage = document.getElementById('decidePage');
    const multiPage = document.getElementById('multiPage');
    const confirmRef = db.ref(`rooms/${roomId}/confirm`);
    const reeditRef = db.ref(`rooms/${roomId}/editConfirm`);

    if (isDeciding && !decidePage.classList.contains('active')) {
        logDebug("loadRoomData: Switching to decidePage");
        multiPage.classList.remove('active');
        decidePage.classList.add('active');
        confirmRef.off('value');
        confirmRef.remove();
        listenReedit(roomId);
        listenVote(roomId);
    } else if (!isDeciding && !multiPage.classList.contains('active')) {
        logDebug("loadRoomData: Switching to multiPage");
        decidePage.classList.remove('active');
        multiPage.classList.add('active');
        reeditRef.off('value');
        reeditRef.remove();
        confirmRef.remove();
        closeAllModals();
        listenConfirmation(roomId);
    } else if (isDeciding) {
        listenReedit(roomId);
        listenVote(roomId);
    }
});

}

async function addItem() {
    logDebug("addItem: Starting item addition");
    const roomId = localStorage.getItem('currentRoomId');
    const input = document.getElementById('itemInput');
    const value = input.value.trim();
    if (!value) {
        logDebug("addItem: Empty input, aborting");
        return;
    }

    const addBtn = document.querySelector('#multiPage .btn-primary[onclick="addItem()"]');
    addBtn.disabled = true;
    addBtn.innerHTML = '<span class="spin-animation">‚è≥</span> Êñ∞Â¢û‰∏≠...';
    logDebug("addItem: Button disabled, adding item");

    const listRef = db.ref('rooms/' + roomId + '/list');
    const maxRetries = 3;
    let attempt = 0;

    while (attempt < maxRetries) {
        try {
            const snapshot = await listRef.once('value');
            let list = snapshot.val() || [];
            list.push(value);
            await listRef.set(list);
            logDebug(`addItem: Added item ${value} to list`);
            input.value = '';
            addBtn.disabled = false;
            addBtn.innerHTML = 'Êñ∞Â¢ûÈ†ÖÁõÆ';
            return;
        } catch (error) {
            attempt++;
            logDebug(`addItem: Error on attempt ${attempt}: ${error.message}`);
            if (attempt === maxRetries) {
                console.error('addItem: Firebase error after retries:', error);
                showModal('Êñ∞Â¢ûÈ†ÖÁõÆÂ§±ÊïóÔºåË´ãÁ®çÂæåÂÜçË©¶ÔºÅ', [
                    { text: 'Â•ΩÁöÑ', class: 'btn-confirm', onClick: () => {} }
                ], 'error');
                addBtn.disabled = false;
                addBtn.innerHTML = 'Êñ∞Â¢ûÈ†ÖÁõÆ';
            }
            await new Promise(resolve => setTimeout(resolve, 1000));
        }
    }
}

async function removeItem(index) {
    logDebug(`removeItem: Attempting to remove item at index ${index}`);
    const roomId = localStorage.getItem('currentRoomId');
    const listRef = db.ref('rooms/' + roomId + '/list');
    const maxRetries = 3;
    let attempt = 0;

    while (attempt < maxRetries) {
        try {
            const snapshot = await listRef.once('value');
            let list = snapshot.val() || [];
            list.splice(index, 1);
            await listRef.set(list);
            logDebug(`removeItem: Removed item at index ${index}`);
            return;
        } catch (error) {
            attempt++;
            logDebug(`removeItem: Error on attempt ${attempt}: ${error.message}`);
            if (attempt === maxRetries) {
                console.error('removeItem: Firebase error after retries:', error);
                showModal('ÁßªÈô§È†ÖÁõÆÂ§±ÊïóÔºåË´ãÁ®çÂæåÂÜçË©¶ÔºÅ', [
                    { text: 'Â•ΩÁöÑ', class: 'btn-confirm', onClick: () => {} }
                ], 'error');
            }
            await new Promise(resolve => setTimeout(resolve, 1000));
        }
    }
}

function shareRoom() {
    logDebug("shareRoom: Initiating room sharing");
    const roomId = localStorage.getItem('currentRoomId');
    const roomRef = db.ref(`rooms/${roomId}`);

    roomRef.once('value').then(snapshot => {
        const data = snapshot.val() || {};
        const roomName = data.name || '';
        const verificationCode = data.code || '';
        const url = `${location.origin}${location.pathname}?room=${encodeURIComponent(roomName)}&code=${encodeURIComponent(verificationCode)}`;
        logDebug(`shareRoom: Generated share URL: ${url}`);

        showModal('Ë´ãÈÅ∏ÊìáÂàÜ‰∫´ÊñπÂºè', [
            {
                text: 'üì§ ÂàÜ‰∫´',
                class: 'btn-primary',
                onClick: () => {
                    logDebug("shareRoom: Share button clicked");
                    if (navigator.share) {
                        navigator.share({
                            title: `Âä†ÂÖ•ÊàëÁöÑÈÅ∏ÊìáÊàøÈñì - ${roomName}`,
                            text: 'ÈªûÊìäÂø´ÈÄüÂä†ÂÖ•ÊàøÈñìÔºÅ',
                            url
                        }).catch(err => {
                            logDebug(`shareRoom: Share failed: ${err.message}`);
                            showModal('ÂàÜ‰∫´Â§±Êïó: ' + err, [
                                { text: 'Â•ΩÁöÑ', class: 'btn-confirm', onClick: () => {} }
                            ], 'error');
                        });
                    } else {
                        logDebug("shareRoom: Device does not support sharing");
                        showModal('Ê≠§Ë£ùÁΩÆ‰∏çÊîØÊè¥Áõ¥Êé•ÂàÜ‰∫´ÂäüËÉΩ', [
                            { text: 'Â•ΩÁöÑ', class: 'btn-confirm', onClick: () => {} }
                        ], 'error');
                    }
                }
            },
            {
                text: 'üìã Ë§áË£ΩÈÄ£Áµê',
                class: 'btn-primary',
                onClick: () => {
                    logDebug("shareRoom: Copy link button clicked");
                    navigator.clipboard.writeText(url)
                        .then(() => {
                            logDebug("shareRoom: Link copied successfully");
                            showModal('Â∑≤Ë§áË£ΩÈÄ£ÁµêÔºåÂèØÁõ¥Êé•Ë≤ºÁµ¶ÊúãÂèãÔºÅ', [
                                { text: 'Â•ΩÁöÑ', class: 'btn-confirm', onClick: () => {} }
                            ], 'success');
                        })
                        .catch(err => {
                            logDebug(`shareRoom: Copy failed: ${err.message}`);
                            showModal('Ë§áË£ΩÂ§±ÊïóÔºåË´ãÊâãÂãïË§áË£Ω', [
                                { text: 'Â•ΩÁöÑ', class: 'btn-confirm', onClick: () => {} }
                            ], 'error');
                        });
                }
            },
            {
                text: '‚ùå ÂèñÊ∂à',
                class: 'btn-confirm',
                onClick: () => {
                    logDebug("shareRoom: Cancel button clicked");
                }
            }
        ], 'share');
    });
}

function listenConfirmation(roomId) {
    logDebug("listenConfirmation: Starting confirmation listener");
    const confirmRef = db.ref(`rooms/${roomId}/confirm`);
    const modalId = 'confirm';
    let lastProcessedData = null;

    confirmRef.on('value', debounce(async snapshot => {
        const data = snapshot.val();
        const dataString = JSON.stringify(data);
        if (dataString === lastProcessedData) {
            logDebug("listenConfirmation: Data unchanged, skipping");
            return;
        }
        closeModalById(modalId); // ÊèêÂâçÈóúÈñâÊ®°ÊÖãÊ°Ü
        lastProcessedData = dataString;
        logDebug(`listenConfirmation: Received data: ${dataString}, User: ${userId}`);

        try {
            const roomSnap = await db.ref(`rooms/${roomId}`).once('value');
            const roomData = roomSnap.val() || {};
            const isDeciding = roomData.isDeciding;
            const hasFinalResult = !!roomData.finalResult;
            logDebug(`listenConfirmation: Room state - isDeciding: ${isDeciding}, hasFinalResult: ${hasFinalResult}`);

            if (isDeciding || hasFinalResult) {
                logDebug("listenConfirmation: Terminating due to isDeciding or finalResult");
                closeAllModals();
                await confirmRef.remove();
                confirmRef.off('value');
                return;
            }

if (!data) {
    logDebug("listenConfirmation: No data, skip showing cancel modal");
    closeAllModals();
    // ÈÄôË£°‰∏çË¶Å showModalÔºåÂõ†ÁÇ∫ confirm Êú¨‰æÜÂ∞±Ê≤íÊúâ
    return;
}


            if (!data.active || data.status === 'cancelled') {
                logDebug("listenConfirmation: Confirmation cancelled or inactive");
                closeAllModals();
                const cancelledByName = data.cancelledBy ? (await db.ref(`rooms/${roomId}/participants/${data.cancelledBy}`).once('value')).val()?.name || 'Êú™Áü•Áî®Êà∂' : 'Êú™Áü•Áî®Êà∂';
                showModal(`‚ùå Á¢∫Ë™çÊµÅÁ®ãÂ∑≤Ë¢´ ${cancelledByName} ÂèñÊ∂à„ÄÇ`, [
                    { text: 'Â•ΩÁöÑ', class: 'btn-confirm', onClick: () => {} }
                ], 'error');
                await confirmRef.remove();
                return;
            }

            if (data.status !== 'pending') {
                logDebug("listenConfirmation: Not pending, cleaning up");
                closeModalById(modalId);
                return;
            }

            if (!data.initiator || !data.initiatorName) {
                logDebug("listenConfirmation: Invalid initiator data, ignoring");
                await confirmRef.remove();
                closeModalById(modalId);
                showModal('‚ùå Á¢∫Ë™çÊµÅÁ®ãÁÑ°ÊïàÔºåÂ∑≤ÂèñÊ∂à„ÄÇ', [
                    { text: 'Â•ΩÁöÑ', class: 'btn-confirm', onClick: () => {} }
                ], 'error');
                return;
            }

            const participantSnap = await db.ref(`rooms/${roomId}/participants`).once('value');
            const participants = participantSnap.val() || {};
            const total = Object.keys(participants).length;
            const responses = data.responses || {};
            const agreeCount = Object.values(responses).filter(v => v === true).length;
            const disagreeCount = Object.values(responses).filter(v => v === false).length;

            // Á¢∫‰øùÁ•®Êï∏Êõ¥Êñ∞
            await confirmRef.update({
                agreeCount: agreeCount,
                disagreeCount: disagreeCount
            });
            logDebug(`listenConfirmation: Updated counts - Agree: ${agreeCount}, Disagree: ${disagreeCount}`);

            const progressText = `ÔºàÁõÆÂâç ${agreeCount} ‰∫∫ÂêåÊÑèÔºå${disagreeCount} ‰∫∫‰∏çÂêåÊÑèÔºâ`;

            if (disagreeCount > 0) {
                logDebug("listenConfirmation: Someone disagreed, cancelling");
                await confirmRef.update({ status: 'cancelled', active: false });
                closeAllModals();
                showModal(`‚ùå Êúâ‰∫∫‰∏çÂêåÊÑèÊ∏ÖÂñÆÔºà${agreeCount} ÂêåÊÑèÔºå${disagreeCount} ‰∏çÂêåÊÑèÔºâÔºåÊµÅÁ®ãÂ∑≤ÂèñÊ∂à„ÄÇ`, [
                    { text: 'Â•ΩÁöÑ', class: 'btn-confirm', onClick: () => {} }
                ], 'error');
                await confirmRef.remove();
                return;
            }

            if (agreeCount === total && total > 0) {
                logDebug("listenConfirmation: All agreed, switching to decidePage");
                await confirmRef.update({ status: 'completed', active: false });
                await db.ref(`rooms/${roomId}/isDeciding`).set(true);
                const multiPage = document.getElementById('multiPage');
                const decidePage = document.getElementById('decidePage');
                if (!decidePage.classList.contains('active')) {
                    logDebug("listenConfirmation: Forcing switch to decidePage");
                    multiPage.classList.remove('active');
                    decidePage.classList.add('active');
                    showModal('‚úÖ ÊâÄÊúâ‰∫∫ÂêåÊÑèÔºåÈÄ≤ÂÖ•ÊäΩÁ±§È†ÅÈù¢ÔºÅ', [
                        { text: 'Â•ΩÁöÑ', class: 'btn-confirm', onClick: () => {} }
                    ], 'success');
                }
                return;
            }

            if (responses[userId] === true) {
                logDebug("listenConfirmation: User has agreed, showing waiting modal");
                showWaitingModal(confirmRef, userId, `Â∑≤ÂêåÊÑèÔºåÁ≠âÂæÖÂÖ∂‰ªñ‰∫∫ÂêåÊÑè‰∏≠... ${progressText}`, modalId);
                return;
            }

            logDebug("listenConfirmation: Showing confirmation modal for user");
closeAllModals();
            showModal(`Â∑≤ÁôºËµ∑Ê∏ÖÂñÆÁ¢∫Ë™çÔºåÊòØÂê¶ÂêåÊÑèÔºü${progressText}`, [
                {
                    text: 'ÂêåÊÑè',
                    class: 'btn-confirm',
                    onClick: async () => {
                        logDebug("listenConfirmation: User agrees");
                        await confirmRef.child('responses').child(userId).set(true);
                        showWaitingModal(confirmRef, userId, `Â∑≤ÂêåÊÑèÔºåÁ≠âÂæÖÂÖ∂‰ªñ‰∫∫ÂêåÊÑè‰∏≠... ${progressText}`, modalId);
                    }
                },
                {
                    text: '‰∏çÂêåÊÑè',
                    class: 'btn-primary',
                    onClick: async () => {
                        logDebug("listenConfirmation: User disagrees");
                        await confirmRef.child('responses').child(userId).set(false);
                    }
                }
            ], modalId);
        } catch (error) {
            logDebug(`listenConfirmation: Error: ${error.message}`);
            showModal('ËôïÁêÜÁ¢∫Ë™çÊµÅÁ®ãÂ§±ÊïóÔºåË´ãÁ®çÂæåÂÜçË©¶ÔºÅ', [
                { text: 'Â•ΩÁöÑ', class: 'btn-confirm', onClick: () => {} }
            ], 'error');
        }
    }, 500));
}

async function requestConfirmation() {
    logDebug("requestConfirmation: Starting confirmation request");
    const roomId = localStorage.getItem('currentRoomId');
    const userId = localStorage.getItem(`currentUserId_${roomId}`);
    if (!userId) {
        logDebug("requestConfirmation: No userId found in localStorage");
        showModal('Áî®Êà∂Ë∫´‰ªΩÈ©óË≠âÂ§±ÊïóÔºåË´ãÈáçÊñ∞Âä†ÂÖ•ÊàøÈñìÔºÅ', [
            { text: 'Â•ΩÁöÑ', class: 'btn-confirm', onClick: () => { window.location.reload(); } }
        ], 'error');
        return;
    }
    logDebug(`requestConfirmation: Current userId: ${userId}`);
    const confirmRef = db.ref(`rooms/${roomId}/confirm`);
    const confirmBtn = document.querySelector('.btn-confirm-red');
    confirmBtn.disabled = true;
    confirmBtn.innerHTML = '<span class="spin-animation">‚è≥</span> Êèê‰∫§‰∏≠...';
    logDebug("requestConfirmation: Button disabled, initiating request");

    try {
        const modeSnap = await db.ref(`rooms/${roomId}/decisionMode`).once('value');
        const mode = modeSnap.val();
        if (!mode) {
            logDebug("requestConfirmation: No decision mode selected");
            showModal('Ë´ãÂÖàÈÅ∏ÊìáÊ±∫ÂÆöÊñπÂºèÔºÅ', [
                { text: 'Â•ΩÁöÑ', class: 'btn-confirm', onClick: () => {} }
            ], 'error');
            confirmBtn.disabled = false;
            confirmBtn.innerHTML = 'ÊàëÂêåÊÑèÊ≠§Ê∏ÖÂñÆ';
            return;
        }

        const isDecidingSnap = await db.ref(`rooms/${roomId}/isDeciding`).once('value');
        if (isDecidingSnap.exists() && isDecidingSnap.val() === true) {
            logDebug("requestConfirmation: Room is already deciding");
            showModal('ÊàøÈñìÊ≠£Âú®ÈÄ≤Ë°åÊ±∫ÂÆö‰∏≠ÔºåË´ãÁ®çÂæåÂÜçË©¶ÔºÅ', [
                { text: 'Â•ΩÁöÑ', class: 'btn-confirm', onClick: () => {} }
            ], 'error');
            confirmBtn.disabled = false;
            confirmBtn.innerHTML = 'ÊàëÂêåÊÑèÊ≠§Ê∏ÖÂñÆ';
            return;
        }

        const participantSnap = await db.ref(`rooms/${roomId}/participants/${userId}`).once('value');
        if (!participantSnap.exists()) {
            logDebug("requestConfirmation: UserId not found in participants");
            showModal('Áî®Êà∂Ë∫´‰ªΩÁÑ°ÊïàÔºåË´ãÈáçÊñ∞Âä†ÂÖ•ÊàøÈñìÔºÅ', [
                { text: 'Â•ΩÁöÑ', class: 'btn-confirm', onClick: () => { window.location.reload(); } }
            ], 'error');
            confirmBtn.disabled = false;
            confirmBtn.innerHTML = 'ÊàëÂêåÊÑèÊ≠§Ê∏ÖÂñÆ';
            return;
        }

        await confirmRef.transaction(currentData => {
            logDebug("requestConfirmation: Clearing confirm data via transaction");
            return null;
        });
        const userName = participantSnap.val().name || 'Êú™Áü•';
        await confirmRef.set({
            active: true,
            initiator: userId,
            initiatorName: userName,
            status: 'pending',
            responses: {},
            agreeCount: 0,    // Êñ∞Â¢ûÔºöÂàùÂßãÂåñÂêåÊÑèÁ•®Êï∏
            disagreeCount: 0, // Êñ∞Â¢ûÔºöÂàùÂßãÂåñ‰∏çÂêåÊÑèÁ•®Êï∏
            timestamp: firebase.database.ServerValue.TIMESTAMP
        });
        logDebug(`requestConfirmation: Set confirm data for initiator ${userName} (${userId})`);
        showWaitingModal(confirmRef, userId, 'Â∑≤ÁôºËµ∑Ê∏ÖÂñÆÁ¢∫Ë™çÔºåÁ≠âÂæÖÊâÄÊúâ‰∫∫ÂêåÊÑè...', 'confirm');
        confirmBtn.disabled = false;
        confirmBtn.innerHTML = 'ÊàëÂêåÊÑèÊ≠§Ê∏ÖÂñÆ';
    } catch (error) {
        logDebug(`requestConfirmation: Firebase error: ${error.message}`);
        console.error('requestConfirmation: Firebase Ë®≠ÂÆöÈåØË™§:', error);
        showModal('Á¢∫Ë™çÊµÅÁ®ãÂïüÂãïÂ§±ÊïóÔºåË´ãÁ®çÂæåÂÜçË©¶ÔºÅ', [
            { text: 'Â•ΩÁöÑ', class: 'btn-confirm', onClick: () => {} }
        ], 'error');
        confirmBtn.disabled = false;
        confirmBtn.innerHTML = 'ÊàëÂêåÊÑèÊ≠§Ê∏ÖÂñÆ';
    }
}

function showWaitingModal(ref, userId, message, modalId) {
    logDebug(`showWaitingModal: Displaying waiting modal ${modalId}`);
    showModal(message, [
        {
            text: 'ÂèñÊ∂à',
            class: 'btn-primary',
            onClick: async () => {
                logDebug(`showWaitingModal: Cancel button clicked for ${modalId} by user ${userId}`);
                try {
                    await ref.update({
                        status: 'cancelled',
                        active: false,
                        cancelledBy: userId,
                        timestamp: firebase.database.ServerValue.TIMESTAMP
                    });
                    logDebug(`showWaitingModal: Set ${modalId} to cancelled state`);
                    closeModalById(modalId);
                } catch (error) {
                    logDebug(`showWaitingModal: Error setting cancelled state: ${error.message}`);
                    showModal('ÂèñÊ∂àÊµÅÁ®ãÂ§±ÊïóÔºåË´ãÁ®çÂæåÂÜçË©¶ÔºÅ', [
                        { text: 'Â•ΩÁöÑ', class: 'btn-confirm', onClick: () => {} }
                    ], 'error');
                }
            }
        }
    ], modalId);
}

async function startDraw() {
    logDebug("startDraw: Starting draw process");
    const drawBtn = document.querySelector('#decidePage .btn-primary[onclick="startDraw()"]');
    drawBtn.disabled = true;
    drawBtn.innerHTML = '<span class="spin-animation">‚è≥</span> ÊäΩÁ±§‰∏≠...';
    const roomId = localStorage.getItem('currentRoomId');
    const roomRef = db.ref(`rooms/${roomId}`);

    try {
        const [finalResultSnap, isDecidingSnap] = await Promise.all([
            roomRef.child('finalResult').once('value'),
            roomRef.child('isDeciding').once('value')
        ]);
        if (finalResultSnap.val() || !isDecidingSnap.val()) {
            logDebug(`startDraw: Invalid state - finalResult: ${finalResultSnap.val()}, isDeciding: ${isDecidingSnap.val()}`);
            showModal(
                finalResultSnap.val()
                    ? `Êú¨Ê¨°ÁµêÊûúÂ∑≤Âá∫Áàê[${finalResultSnap.val()}]ÔºåË´ãÈáçÊñ∞Á∑®ËºØÊ∏ÖÂñÆ‰ª•ÈñãÂßãÊñ∞ÊäΩÁ±§ÔºÅ`
                    : 'ÊàøÈñìÁãÄÊÖãÁÑ°ÊïàÔºåË´ãÈáçÊñ∞Á¢∫Ë™çÊ∏ÖÂñÆÔºÅ',
                [
                    { text: 'Â•ΩÁöÑ', class: 'btn-confirm', onClick: () => {} }
                ],
                'error'
            );
            drawBtn.disabled = false;
            drawBtn.innerHTML = 'üé≤ ÈñãÂßãÊäΩÁ±§';
            return;
        }

        const [listSnap, modeSnap] = await Promise.all([
            roomRef.child('list').once('value'),
            roomRef.child('decisionMode').once('value')
        ]);
        const items = listSnap.val() || [];
        const mode = modeSnap.val() || '‰∏ÄÊäΩÂÖ•È≠Ç';
        logDebug(`startDraw: Items count: ${items.length}, Mode: ${mode}`);

        if (items.length === 0) {
            logDebug("startDraw: No items to draw");
            showModal('‚ö†Ô∏è ÁõÆÂâçÊ≤íÊúâÂèØÊäΩÁ±§ÁöÑÈ†ÖÁõÆ', [
                { text: 'Â•ΩÁöÑ', class: 'btn-confirm', onClick: () => {} }
            ], 'error');
            roomRef.child('isDrawing').remove();
            drawBtn.disabled = false;
            drawBtn.innerHTML = 'üé≤ ÈñãÂßãÊäΩÁ±§';
            return;
        }

        const finalItem = items[Math.floor(Math.random() * items.length)];
        const spinList = [];
        for (let i = 0; i < 35; i++) {
            spinList.push(items[Math.floor(Math.random() * items.length)]);
        }
        spinList.push(finalItem);
        logDebug(`startDraw: Generated spinList, finalItem: ${finalItem}`);

        await roomRef.update({
            isDrawing: true,
            drawResult: finalItem,
            drawAnimation: spinList,
            vote: null // Clear vote data before draw
        });
        logDebug("startDraw: Updated Firebase with draw data");
        drawBtn.disabled = false;
        drawBtn.innerHTML = 'üé≤ ÈñãÂßãÊäΩÁ±§';
    } catch (error) {
        logDebug(`startDraw: Firebase error: ${error.message}`);
        showModal('ÊäΩÁ±§Â§±ÊïóÔºåË´ãÁ®çÂæåÂÜçË©¶ÔºÅ', [
            { text: 'Â•ΩÁöÑ', class: 'btn-confirm', onClick: () => {} }
        ], 'error');
        drawBtn.disabled = false;
        drawBtn.innerHTML = 'üé≤ ÈñãÂßãÊäΩÁ±§';
    }
}
function chooseDecisionMode() {
    logDebug("chooseDecisionMode: Opening decision mode modal");
    showModal('ÈÅ∏ÊìáÊ±∫ÂÆöÊñπÂºè', [
        { text: '‰∏ÄÊäΩÂÖ•È≠Ç', onClick: () => setDecisionMode('‰∏ÄÊäΩÂÖ•È≠Ç') },
        { text: 'Â§öÊï∏Ê±∫', onClick: () => setDecisionMode('Â§öÊï∏Ê±∫') },
        { text: 'ÂÖ±Ë≠òÊ±∫', onClick: () => setDecisionMode('ÂÖ±Ë≠òÊ±∫') }
    ], 'decisionMode');
}

async function setDecisionMode(mode) {
    logDebug(`setDecisionMode: Setting mode to ${mode}`);
    const roomId = localStorage.getItem('currentRoomId');
    try {
        await db.ref(`rooms/${roomId}/decisionMode`).set(mode);
        document.getElementById('selectedMode').textContent = `Â∑≤ÈÅ∏ÊìáÔºö${mode}`;
        logDebug(`setDecisionMode: Successfully set mode ${mode}`);
    } catch (error) {
        logDebug(`setDecisionMode: Firebase error: ${error.message}`);
        console.error('setDecisionMode: Firebase error:', error);
        showModal('Ë®≠ÁΩÆÊ±∫ÂÆöÊñπÂºèÂ§±ÊïóÔºåË´ãÁ®çÂæåÂÜçË©¶ÔºÅ', [
            { text: 'Â•ΩÁöÑ', class: 'btn-confirm', onClick: () => {} }
        ], 'error');
    }
}

function showFinalResult(result) {
    logDebug(`showFinalResult: Displaying final result: ${result}`);
    const roomId = localStorage.getItem('currentRoomId');
    const confirmRef = db.ref(`rooms/${roomId}/confirm`);
    const reeditRef = db.ref(`rooms/${roomId}/editConfirm`);
    const voteRef = db.ref(`rooms/${roomId}/vote`);

    confirmRef.remove();
    reeditRef.remove();
    voteRef.remove();
    voteRef.off('value');
    closeAllModals();
    logDebug("showFinalResult: Cleared confirm, reedit, and vote data");

    const modal = document.createElement('div');
    modal.className = 'modal';
    modal.dataset.modalId = 'finalResult';
    const modalContent = document.createElement('div');
    modalContent.className = 'modal-content';
    modalContent.innerHTML = `
        <h2 style="font-size:2em;">üéâ ÊúÄÁµÇÁµêÊûú üéâ</h2>
        <p style="font-size:1.8em; color:#3db8c4; font-weight:bold; margin: 20px 0;">${result}</p>
        <p style="font-size:1em;">Êú¨Ê¨°ÁµêÊûúÂ∑≤Âá∫ÁàêÔºåË´ãÂãôÂøÖÈÅµÂÆàÂì¶ÔºÅ</p>
    `;

    confettiEffect();

    const btn = document.createElement('button');
btn.className = 'btn-confirm';
btn.textContent = 'ÈóúÈñâ';
btn.onclick = () => {
    logDebug("showFinalResult: Close button clicked");
    modal.remove();
    const drawBtn = document.querySelector('#decidePage .btn-primary[onclick="startDraw()"]');
    if (drawBtn) drawBtn.disabled = false; // Á¢∫‰øùÊåâÈàïÁ¶ÅÁî®
};
modalContent.appendChild(btn);
    modal.appendChild(modalContent);
    document.body.appendChild(modal);
}

function confettiEffect() {
    logDebug("confettiEffect: Starting confetti animation");
    for (let i = 0; i < 30; i++) {
        const confetti = document.createElement('div');
        confetti.textContent = 'üéä';
        confetti.style.position = 'fixed';
        confetti.style.top = '-50px';
        confetti.style.left = Math.random() * 100 + 'vw';
        confetti.style.fontSize = '2em';
        confetti.style.animation = `fall ${2 + Math.random() * 3}s linear forwards`;
        document.body.appendChild(confetti);
        confetti.addEventListener('animationend', () => {
            confetti.remove();
        });
    }
}

async function initiateVoting(mode, finalItem) {
    logDebug(`initiateVoting: Starting voting for item ${finalItem}, mode: ${mode}`);
    const roomId = localStorage.getItem('currentRoomId');
    const voteRef = db.ref(`rooms/${roomId}/vote`);
    try {
        if (!finalItem) {
            logDebug("initiateVoting: Invalid finalItem");
            showModal('ÊäΩÁ±§ÁµêÊûúÁÑ°ÊïàÔºåË´ãÈáçÊñ∞ÊäΩÁ±§ÔºÅ', [
                { text: 'Â•ΩÁöÑ', class: 'btn-confirm', onClick: () => {} }
            ], 'error');
            return;
        }
        // ÂÖàÊ™¢Êü•ÊòØÂê¶Â∑≤Á∂ìÊúâÊäïÁ•®Ë≥áÊñôÔºåÊ≤íÊúâÂÜçÂØ´
        const voteSnap = await voteRef.once('value');
        if (voteSnap.exists()) {
            logDebug("initiateVoting: Voting already initialized, skip.");
            return;
        }
        await voteRef.set({
            active: true,
            item: finalItem,
            mode: mode,
            votes: {},
            timestamp: firebase.database.ServerValue.TIMESTAMP
        });
        logDebug("initiateVoting: Voting initialized");
    } catch (error) {
        logDebug(`initiateVoting: Firebase error: ${error.message}`);
        showModal('ÊäïÁ•®ÂïüÂãïÂ§±ÊïóÔºåË´ãÁ®çÂæåÂÜçË©¶ÔºÅ', [
            { text: 'Â•ΩÁöÑ', class: 'btn-confirm', onClick: () => {} }
        ], 'error');
    }
}


async function requestReedit() {
    logDebug("requestReedit: Starting reedit request");
    const roomId = localStorage.getItem('currentRoomId');
    const userId = localStorage.getItem(`currentUserId_${roomId}`);
    if (!userId) {
        logDebug("requestReedit: No userId found in localStorage");
        showModal('Áî®Êà∂Ë∫´‰ªΩÈ©óË≠âÂ§±ÊïóÔºåË´ãÈáçÊñ∞Âä†ÂÖ•ÊàøÈñìÔºÅ', [
            { text: 'Â•ΩÁöÑ', class: 'btn-confirm', onClick: () => { window.location.reload(); } }
        ], 'error');
        return;
    }
    logDebug(`requestReedit: Current userId: ${userId}`);
    const reeditRef = db.ref(`rooms/${roomId}/editConfirm`);
    const reeditBtn = document.querySelector('#decidePage .btn-primary[onclick="requestReedit()"]');
    reeditBtn.disabled = true;
    reeditBtn.innerHTML = '<span class="spin-animation">‚è≥</span> Êèê‰∫§‰∏≠...';
    logDebug("requestReedit: Button disabled, initiating request");

    try {
        const participantSnap = await db.ref(`rooms/${roomId}/participants/${userId}`).once('value');
        if (!participantSnap.exists()) {
            logDebug("requestReedit: UserId not found in participants");
            showModal('Áî®Êà∂Ë∫´‰ªΩÁÑ°ÊïàÔºåË´ãÈáçÊñ∞Âä†ÂÖ•ÊàøÈñìÔºÅ', [
                { text: 'Â•ΩÁöÑ', class: 'btn-confirm', onClick: () => { window.location.reload(); } }
            ], 'error');
            reeditBtn.disabled = false;
            reeditBtn.innerHTML = '‚Üê ÈáçÊñ∞Á∑®ËºØ';
            return;
        }

        // ÊîπÂãïÔºöÁßªÈô§Ëá™ÂãïÂêåÊÑèÔºåÂÉÖË®≠ÁΩÆÈáçÊñ∞Á∑®ËºØË´ãÊ±Ç
        await reeditRef.transaction(currentData => {
            logDebug("requestReedit: Clearing reedit data via transaction");
            return null;
        });
        const userName = participantSnap.val().name || 'Êú™Áü•';
        await reeditRef.set({
            active: true,
            initiator: userId,
            initiatorName: userName,
            status: 'pending',
            responses: {}, // ÊîπÂãïÔºö‰∏çÈ†êË®≠ÁôºËµ∑‰∫∫ÂêåÊÑè
            timestamp: firebase.database.ServerValue.TIMESTAMP
        });
        logDebug(`requestReedit: Set reedit data for initiator ${userName} (${userId})`);
        showWaitingModal(reeditRef, userId, 'Â∑≤ÁôºËµ∑ÈáçÊñ∞Á∑®ËºØÔºåÁ≠âÂæÖÊâÄÊúâ‰∫∫ÂêåÊÑè...', 'reedit');
        reeditBtn.disabled = false;
        reeditBtn.innerHTML = '‚Üê ÈáçÊñ∞Á∑®ËºØ';
    } catch (error) {
        logDebug(`requestReedit: Firebase error: ${error.message}`);
        console.error('requestReedit: Firebase Ë®≠ÂÆöÈåØË™§:', error);
        showModal('ÈáçÊñ∞Á∑®ËºØË´ãÊ±ÇÂ§±ÊïóÔºåË´ãÁ®çÂæåÂÜçË©¶ÔºÅ', [
            { text: 'Â•ΩÁöÑ', class: 'btn-confirm', onClick: () => {} }
        ], 'error');
        reeditBtn.disabled = false;
        reeditBtn.innerHTML = '‚Üê ÈáçÊñ∞Á∑®ËºØ';
    }
}

function listenReedit(roomId) {
    logDebug("listenReedit: Starting reedit listener");
    const reeditRef = db.ref(`rooms/${roomId}/editConfirm`);
    const modalId = 'reedit';
    let lastProcessedData = null;

    reeditRef.on('value', debounce(async snap => {
        const data = snap.val();
        const dataString = JSON.stringify(data);
        if (dataString === lastProcessedData) {
            logDebug("listenReedit: Data unchanged, skipping");
            return;
        }
        lastProcessedData = dataString;
        logDebug(`listenReedit: Received data: ${dataString}, User: ${userId}`);

        try {
            const roomSnap = await db.ref(`rooms/${roomId}`).once('value');
            const roomData = roomSnap.val() || {};
            const isDeciding = roomData.isDeciding;
            logDebug(`listenReedit: isDeciding: ${isDeciding}`);

            if (!isDeciding) {
                logDebug("listenReedit: Not in deciding phase, clearing reedit data");
                await reeditRef.remove();
                closeModalById(modalId);
                return;
            }

            if (!data) {
                logDebug("listenReedit: editConfirm is null, closing modal");
                closeModalById(modalId);
                return;
            }

            if (data.status === 'cancelled') {
                logDebug("listenReedit: Reedit process cancelled!");
                closeAllModals();
                // ÊâæÂá∫ÂèçÂ∞çËÄÖÂêçÁ®±ÔºàÊàñÊú™Áü•Áî®Êà∂Ôºâ
                let cancelledByName = 'Êú™Áü•Áî®Êà∂';
                if (data.responses) {
                    const refusers = Object.entries(data.responses).filter(([uid, v]) => v === false);
                    if (refusers.length > 0) {
                        const [refuseId] = refusers[0];
                        const snap = await db.ref(`rooms/${roomId}/participants/${refuseId}`).once('value');
                        cancelledByName = snap.val() && snap.val().name ? snap.val().name : 'Êú™Áü•Áî®Êà∂';
                    }
                }
closeAllModals();
                showModal(
                    `‚ùÖ ÈáçÊñ∞Á∑®ËºØÊµÅÁ®ãÂ∑≤Ë¢´ ${cancelledByName} ÂèñÊ∂àÔºÅ`,
                    [{ text: 'Â•ΩÁöÑ', class: 'btn-confirm', onClick: () => {} }],
                    'error'
                );
                // ‰∏çÂàáÈ†ÅÔºÅÂè™È°ØÁ§∫Ë®äÊÅØ
                return;
            }

            if (!data.active || data.status !== 'pending') {
                logDebug("listenReedit: No active reedit or not pending, cleaning up");
                await reeditRef.remove();
                closeModalById(modalId);
                return;
            }

            if (!data.initiator || !data.initiatorName) {
                logDebug("listenReedit: Invalid initiator data, ignoring");
                await reeditRef.remove();
                closeModalById(modalId);
                return;
            }

            const participantSnap = await db.ref(`rooms/${roomId}/participants`).once('value');
            const participants = participantSnap.val() || {};
            const total = Object.keys(participants).length;
            const responses = data.responses || {};
            const agreeCount = Object.values(responses).filter(v => v === true).length;
            const disagreeCount = Object.values(responses).filter(v => v === false).length;
            logDebug(`listenReedit: Total participants: ${total}, Agree: ${agreeCount}, Disagree: ${disagreeCount}, User: ${userId}`);

            // Êõ¥Êñ∞Á•®Êï∏
            await reeditRef.update({
                agreeCount: agreeCount,
                disagreeCount: disagreeCount
            });
            logDebug(`listenReedit: Updated counts - Agree: ${agreeCount}, Disagree: ${disagreeCount}`);

            const progressText = `ÔºàÁõÆÂâç ${agreeCount} ‰∫∫ÂêåÊÑèÔºå${disagreeCount} ‰∫∫‰∏çÂêåÊÑèÔºâ`;

            // Âè™Ë¶ÅÊúâ‰∫∫‰∏çÂêåÊÑèÔºåÂ∞±ÂΩàÁ™óÔºå‰∏çÂãï‰ªª‰ΩïÁãÄÊÖãÔºå‰∏çÂàáÈ†Å
            if (disagreeCount > 0) {
                logDebug("listenReedit: Someone disagreed, cancelling");
                await reeditRef.update({ status: 'cancelled', active: false });
                closeAllModals();
                showModal(
                    `‚ùÖ Êúâ‰∫∫‰∏çÂêåÊÑèÈáçÊñ∞Á∑®ËºØÔºà${agreeCount} ÂêåÊÑèÔºå${disagreeCount} ‰∏çÂêåÊÑèÔºâÔºåÊµÅÁ®ãÂ∑≤ÂèñÊ∂à„ÄÇ`,
                    [{ text: 'Â•ΩÁöÑ', class: 'btn-confirm', onClick: () => {} }],
                    'error'
                );
                // ‰∏çÂàáÈ†Å„ÄÅ‰∏çÂãï isDeciding
                return;
            }

            // Âè™ÊúâÂÖ®ÂêåÊÑèÔºåÊâçÂàáÈ†ÅÈÇÑÂéüÊâÄÊúâÁãÄÊÖã
            if (agreeCount === total && total > 0) {
                logDebug("listenReedit: All agreed, returning to multiPage");
                await reeditRef.update({ status: 'completed', active: false });
                await db.ref(`rooms/${roomId}`).update({
                    isDeciding: null,
                    finalResult: null,
                    drawResult: null,
                    isDrawing: null,
                    vote: null,
                    confirm: null,
                    editConfirm: null
                });
                closeAllModals();
                showModal('‚úÖ ÊâÄÊúâ‰∫∫ÂêåÊÑèÔºåËøîÂõûÁ∑®ËºØÊ∏ÖÂñÆÔºÅ', [
                    {
                        text: 'Â•ΩÁöÑ',
                        class: 'btn-confirm',
                        onClick: () => {
                            const decidePage = document.getElementById('decidePage');
                            const multiPage = document.getElementById('multiPage');
                            if (!multiPage.classList.contains('active')) {
                                decidePage.classList.remove('active');
                                multiPage.classList.add('active');
                                listenVote(roomId);
                            }
                        }
                    }
                ], 'success');
                return;
            }

            // Â∑≤ÂêåÊÑèÁöÑÁî®Êà∂ÔºåÈ°ØÁ§∫Á≠âÂæÖ
            if (responses[userId] === true) {
                logDebug("listenReedit: User has agreed, showing waiting modal");
                closeAllModals();
                showWaitingModal(reeditRef, userId, `Â∑≤ÂêåÊÑèÔºåÁ≠âÂæÖÂÖ∂‰ªñ‰∫∫ÂêåÊÑè‰∏≠... ${progressText}`, modalId);
                return;
            }

            // Â∞öÊú™Ë°®ÊÖãÔºåÈ°ØÁ§∫ÂêåÊÑè/‰∏çÂêåÊÑèÈÅ∏Êìá
            logDebug("listenReedit: Showing confirmation modal for user");
            closeAllModals();
            showModal(`Â∑≤ÁôºËµ∑ÈáçÊñ∞Á∑®ËºØÔºåÊòØÂê¶ÂêåÊÑèÔºü${progressText}`, [
                {
                    text: 'ÂêåÊÑè',
                    class: 'btn-confirm',
                    onClick: async () => {
                        logDebug("listenReedit: User agrees");
                        await reeditRef.child('responses').child(userId).set(true);
                        closeAllModals();
                        showWaitingModal(reeditRef, userId, `Â∑≤ÂêåÊÑèÔºåÁ≠âÂæÖÂÖ∂‰ªñ‰∫∫ÂêåÊÑè‰∏≠... ${progressText}`, modalId);
                    }
                },
                {
                    text: '‰∏çÂêåÊÑè',
                    class: 'btn-primary',
                    onClick: async () => {
                        logDebug("listenReedit: User disagrees");
                        await reeditRef.child('responses').child(userId).set(false);
                        closeModalById(modalId);
                        // ‰∏çÂÅö‰ªª‰ΩïÂàáÈ†ÅÔºåÂè™ÂΩàÁ™óÔºÅ
                    }
                }
            ], modalId);

        } catch (error) {
            logDebug(`listenReedit: Error: ${error.message}`);
            showModal('ÈáçÊñ∞Á∑®ËºØËôïÁêÜÂ§±ÊïóÔºåË´ãÁ®çÂæåÂÜçË©¶ÔºÅ', [
                { text: 'Â•ΩÁöÑ', class: 'btn-confirm', onClick: () => {} }
            ], 'error');
        }
    }, 500));
}

async function playDrawAnimation(roomId) {
    logDebug("playDrawAnimation: Starting draw animation");
    const roomRef = db.ref(`rooms/${roomId}`);
    try {
        const finalResultSnap = await roomRef.child('finalResult').once('value');
        if (finalResultSnap.val()) {
            logDebug(`playDrawAnimation: Final result already exists: ${finalResultSnap.val()}`);
            showModal(`Êú¨Ê¨°ÁµêÊûú[${finalResultSnap.val()}]ÔºåË´ãÂãôÂøÖÈÅµÂÆàÂì¶ÔºÅ`, [
                { text: 'Â•ΩÁöÑ', class: 'btn-confirm', onClick: () => {} }
            ], 'info');
            return;
        }

        const [spinListSnap, resultSnap, modeSnap] = await Promise.all([
            roomRef.child('drawAnimation').once('value'),
            roomRef.child('drawResult').once('value'),
            roomRef.child('decisionMode').once('value')
        ]);
        const spinList = spinListSnap.val() || [];
        const finalItem = resultSnap.val();
        const mode = modeSnap.val() || '‰∏ÄÊäΩÂÖ•È≠Ç';

        if (!spinList.length || !finalItem) {
            logDebug("playDrawAnimation: Invalid spinList or finalItem");
            showModal('ÊäΩÁ±§ÂãïÁï´Êï∏ÊìöÊú™ËºâÂÖ•ÔºåË´ãÈáçÊñ∞ÊäΩÁ±§ÔºÅ', [
                { text: 'Â•ΩÁöÑ', class: 'btn-confirm', onClick: () => {} }
            ], 'error');
            roomRef.update({ isDrawing: null, drawAnimation: null });
            return;
        }

        closeModalById('drawAnimation');
        const modal = document.createElement('div');
        modal.className = 'modal';
        modal.dataset.modalId = 'drawAnimation';
        const modalContent = document.createElement('div');
        modalContent.className = 'modal-content';
        const resultArea = document.createElement('p');
        resultArea.style.fontSize = '2em';
        resultArea.className = 'spin-animation';
        resultArea.textContent = 'üé∞ ÊäΩÁ±§‰∏≠...';
        modalContent.appendChild(resultArea);
        modal.appendChild(modalContent);
        document.body.appendChild(modal);
        logDebug("playDrawAnimation: Displayed draw animation modal");

        let index = 0;
        function animate() {
            if (index >= spinList.length) {
                resultArea.className = 'result-final';
                resultArea.textContent = finalItem;
                logDebug(`playDrawAnimation: Final item: ${finalItem}`);
                setTimeout(() => {
                    modal.remove();
                    roomRef.update({
                        isDrawing: null,
                        drawAnimation: null
                    }).then(() => {
                        logDebug("playDrawAnimation: Cleared draw data");
                        if (mode === '‰∏ÄÊäΩÂÖ•È≠Ç') {
                            roomRef.update({ finalResult: finalItem }).then(() => {
                                logDebug("playDrawAnimation: Set finalResult for ‰∏ÄÊäΩÂÖ•È≠Ç");
                            });
                        } else {
                            initiateVoting(mode, finalItem).then(() => {
                                logDebug("playDrawAnimation: Voting initiated");
                                listenVote(roomId); // Reattach vote listener
                            });
                        }
                    }).catch(error => {
                        logDebug(`playDrawAnimation: Firebase update error: ${error.message}`);
                        showModal('ÊäΩÁ±§ÂÆåÊàêÂ§±ÊïóÔºåË´ãÈáçÊñ∞ÊäΩÁ±§ÔºÅ', [
                            { text: 'Â•ΩÁöÑ', class: 'btn-confirm', onClick: () => {} }
                        ], 'error');
                    });
                }, 2000);
                return;
            }

            resultArea.textContent = spinList[index];
            logDebug(`playDrawAnimation: Showing item ${spinList[index]} at index ${index}`);
            index++;
            setTimeout(() => requestAnimationFrame(animate), 100); // Add slight delay for smoother animation
        }

        requestAnimationFrame(animate);
    } catch (error) {
        logDebug(`playDrawAnimation: Firebase error: ${error.message}`);
        console.error('playDrawAnimation: Firebase error:', error);
        showModal('ÊäΩÁ±§ÂãïÁï´Â§±ÊïóÔºåË´ãÈáçÊñ∞ÊäΩÁ±§ÔºÅ', [
            { text: 'Â•ΩÁöÑ', class: 'btn-confirm', onClick: () => {} }
        ], 'error');
        roomRef.update({ isDrawing: null, drawAnimation: null });
    }
}
async function importItems() {
    logDebug("importItems: Starting item import");
    const roomId = localStorage.getItem('currentRoomId');
    const text = prompt('Ë´ãË≤º‰∏äË¶ÅÂåØÂÖ•ÁöÑÈ†ÖÁõÆÔºàJSON ÊàñÊØèË°å‰∏ÄÈ†ÖÔºâÔºö');
    if (!text) {
        logDebug("importItems: No input provided");
        return;
    }
    let items = [];
    try {
        const parsed = JSON.parse(text);
        if (parsed.items) items = parsed.items;
        else throw new Error();
    } catch {
        items = text.split('\n').map(s => s.trim()).filter(Boolean);
    }
    if (items.length === 0) {
        logDebug("importItems: No valid items to import");
        return;
    }
    logDebug(`importItems: Parsed ${items.length} items`);

    const importBtn = document.querySelector('#multiPage .btn-primary[onclick="importItems()"]');
    importBtn.disabled = true;
    importBtn.innerHTML = '<span class="spin-animation">‚è≥</span> ÂåØÂÖ•‰∏≠...';
    logDebug("importItems: Button disabled, importing items");

    const listRef = db.ref('rooms/' + roomId + '/list');
    const maxRetries = 3;
    let attempt = 0;

    while (attempt < maxRetries) {
        try {
            const snapshot = await listRef.once('value');
            let list = snapshot.val() || [];
            list = list.concat(items);
            await listRef.set(list);
            logDebug(`importItems: Imported ${items.length} items`);
            importBtn.disabled = false;
            importBtn.innerHTML = 'ÂåØÂÖ•';
            return;
        } catch (error) {
            attempt++;
            logDebug(`importItems: Error on attempt ${attempt}: ${error.message}`);
            if (attempt === maxRetries) {
                console.error('importItems: Firebase error after retries:', error);
                showModal('ÂåØÂÖ•È†ÖÁõÆÂ§±ÊïóÔºåË´ãÁ®çÂæåÂÜçË©¶ÔºÅ', [
                    { text: 'Â•ΩÁöÑ', class: 'btn-confirm', onClick: () => {} }
                ], 'error');
                importBtn.disabled = false;
                importBtn.innerHTML = 'ÂåØÂÖ•';
            }
            await new Promise(resolve => setTimeout(resolve, 1000));
        }
    }
}

function listenVote(roomId) {
    logDebug("listenVote: Starting vote listener");
    const voteRef = db.ref(`rooms/${roomId}/vote`);
    const modalId = 'vote';
    let lastProcessedData = null;

    voteRef.on('value', debounce(async snap => {
        const data = snap.val();
        const dataString = JSON.stringify(data);
        if (dataString === lastProcessedData) {
            logDebug("listenVote: Data unchanged, skipping");
            return;
        }
        lastProcessedData = dataString;
        logDebug(`listenVote: Received data: ${dataString}`);

        try {
            const finalResultSnap = await db.ref(`rooms/${roomId}/finalResult`).once('value');
            if (finalResultSnap.val()) {
                logDebug("listenVote: Final result exists, terminating vote listener");
                await voteRef.remove();
                voteRef.off('value');
                closeModalById(modalId);
                return;
            }

if (!data || !data.active || !data.item || data.status === 'cancelled') {
    logDebug("listenVote: No active vote or invalid item, removing listener and clearing vote");
    closeModalById(modalId);
    await voteRef.remove();
    voteRef.off('value');
    return;
}

            const item = data.item;
            const mode = data.mode;
            const votes = data.votes || {};

            const participantSnap = await db.ref(`rooms/${roomId}/participants`).once('value');
            const participants = participantSnap.val() || {};
            const total = Object.keys(participants).length;
            const agreeCount = Object.values(votes).filter(v => v === true).length;
            const disagreeCount = Object.values(votes).filter(v => v === false).length;
            const totalVotes = Object.keys(votes).length;
            logDebug(`listenVote: Total participants: ${total}, Agree: ${agreeCount}, Disagree: ${disagreeCount}, Total votes: ${totalVotes}`);

            // Á¢∫‰øùÁ•®Êï∏Êõ¥Êñ∞
            await voteRef.update({
                agreeCount: agreeCount,
                disagreeCount: disagreeCount
            });
            logDebug(`listenVote: Updated counts - Agree: ${agreeCount}, Disagree: ${disagreeCount}`);

            const progressText = `ÔºàÁõÆÂâç ${agreeCount} ‰∫∫ÂêåÊÑèÔºå${disagreeCount} ‰∫∫‰∏çÂêåÊÑèÔºâ`;

            if (!(userId in votes)) {
                logDebug(`listenVote: User ${userId} has not voted, showing vote modal`);
                closeAllModals();
                showModal(`ÊòØÂê¶ÂêåÊÑèÂ∞á„Äå${item}„Äç‰ΩúÁÇ∫ÊúÄÁµÇÁµêÊûúÔºü${progressText}`, [
    {
        text: 'ÂêåÊÑè',
        class: 'btn-confirm',
        onClick: async () => {
            logDebug('‰Ω†Êåâ‰∫ÜÂêåÊÑèÔºÅuserId=' + userId);
            closeModalById(modalId);
            await voteRef.child('votes/' + userId).set(true)
                .then(() => logDebug('set(true) ÂØ´ÂÖ•ÊàêÂäüÔºÅ'))
                .catch(e => logDebug('set(true) Â§±ÊïóÔºö' + e.message));
            showWaitingModal(voteRef, userId, `Â∑≤ÂêåÊÑèÔºåÁ≠âÂæÖÂÖ∂‰ªñ‰∫∫ÊäïÁ•®‰∏≠... ${progressText}`, modalId);
            lastProcessedData = null; // Reset to ensure updates
        }
    },
    {
        text: '‰∏çÂêåÊÑè',
        class: 'btn-primary',
        onClick: async () => {
            logDebug('‰Ω†Êåâ‰∫Ü‰∏çÂêåÊÑèÔºÅuserId=' + userId);
            closeAllModals();
            await voteRef.child('votes/' + userId).set(false)
                .then(() => logDebug('set(false) ÂØ´ÂÖ•ÊàêÂäüÔºÅ'))
                .catch(e => logDebug('set(false) Â§±ÊïóÔºö' + e.message));
            lastProcessedData = null; // Reset to ensure updates
        }
    }
], modalId);

            } else {
                logDebug(`listenVote: User ${userId} has voted, showing waiting modal`);
                showWaitingModal(voteRef, userId, `Â∑≤ÊäïÁ•®ÔºåÁ≠âÂæÖÂÖ∂‰ªñ‰∫∫ÊäïÁ•®‰∏≠... ${progressText}`, modalId);
            }

            let passed = false;
            if (mode === 'ÂÖ±Ë≠òÊ±∫' && agreeCount === total && totalVotes === total) passed = true;
            if (mode === 'Â§öÊï∏Ê±∫' && agreeCount > total / 2) passed = true;

            // Â§öÊï∏Ê±∫ËàáÂÖ±Ë≠òÊ±∫ÂàÜÈñãÂà§Êñ∑
if (mode === 'ÂÖ±Ë≠òÊ±∫') {
    // ÂÖ±Ë≠òÊ±∫ÔºöÂÖ®Âì°ÂêåÊÑèÊâçÈÄöÈÅé
    if (totalVotes === total) {
        if (agreeCount === total) {
            await db.ref(`rooms/${roomId}`).update({
                finalResult: item,
                isDrawing: null
            });
            closeAllModals();
            voteRef.off('value');
        } else {
            closeAllModals();
            showModal(
                `‚ùå Êú™ÈÅîÊàêÊ¢ù‰ª∂Ôºà${agreeCount} ÂêåÊÑèÔºå${disagreeCount} ‰∏çÂêåÊÑèÔºâÔºåË´ãÂÜçÊäΩ‰∏ÄÊ¨°ÔºÅ`,
                [{ text: 'Â•ΩÁöÑ', class: 'btn-confirm', onClick: async () => {
                    await db.ref(`rooms/${roomId}`).update({
                        vote: null,
                        isDrawing: null,
                        drawAnimation: null,
                        drawResult: null
                    });
                    const drawBtn = document.querySelector('#decidePage .btn-primary[onclick="startDraw()"]');
                    if (drawBtn) drawBtn.disabled = false;
                }}],
                'error'
            );
        }
    }
} else if (mode === 'Â§öÊï∏Ê±∫') {
    // Â§öÊï∏Ê±∫ÔºöÂè™Ë¶ÅÈÅéÂçäÂ∞±ÈÄöÈÅéÔºà**Ë¶ÅÁ≠âÂÖ®Âì°ÊäïÂÆåÊâçÂà§Êñ∑**Ôºâ
    if (totalVotes === total) {
        if (agreeCount > total / 2) {
            await db.ref(`rooms/${roomId}`).update({
                finalResult: item,
                isDrawing: null
            });
            closeAllModals();
            voteRef.off('value');
        } else {
            closeAllModals();
            showModal(
                `‚ùå Êú™ÈÅîÊàêÊ¢ù‰ª∂Ôºà${agreeCount} ÂêåÊÑèÔºå${disagreeCount} ‰∏çÂêåÊÑèÔºâÔºåË´ãÂÜçÊäΩ‰∏ÄÊ¨°ÔºÅ`,
                [{ text: 'Â•ΩÁöÑ', class: 'btn-confirm', onClick: async () => {
                    await db.ref(`rooms/${roomId}`).update({
                        vote: null,
                        isDrawing: null,
                        drawAnimation: null,
                        drawResult: null
                    });
                    const drawBtn = document.querySelector('#decidePage .btn-primary[onclick="startDraw()"]');
                    if (drawBtn) drawBtn.disabled = false;
                }}],
                'error'
            );
        }
    }
}



        } catch (error) {
            logDebug(`listenVote: Error: ${error.message}`);
            showModal('ÊäïÁ•®ËôïÁêÜÂ§±ÊïóÔºåË´ãÁ®çÂæåÂÜçË©¶ÔºÅ', [
                { text: 'Â•ΩÁöÑ', class: 'btn-confirm', onClick: () => {} }
            ], 'error');
        }
    }, 500));
}
function leaveRoom() {
    logDebug("leaveRoom: Initiating room exit");
    showModal('Á¢∫ÂÆöË¶ÅÈõ¢ÈñãÊ≠§ÊàøÈñìÂóéÔºü', [
        {
            text: 'Á¢∫ÂÆö',
            class: 'btn-confirm',
            onClick: () => {
                logDebug("leaveRoom: Confirm leave clicked");
                const roomId = localStorage.getItem('currentRoomId');
                const userId = localStorage.getItem(`currentUserId_${roomId}`);
                const roomRef = db.ref(`rooms/${roomId}`);

                roomRef.child('participants').transaction(participants => {
                    if (!participants) return;
                    delete participants[userId];
                    const participantCount = Object.keys(participants).length;
                    roomRef.child('participants/' + userId).remove();
                    logDebug(`leaveRoom: Removed user ${userId}, remaining: ${participantCount}`);

                    if (participantCount === 0) {
                        roomRef.update({
                            drawResult: null,
                            finalResult: null,
                            isDrawing: null,
                            vote: null,
                            confirm: null,
                            editConfirm: null
                        });
                        logDebug("leaveRoom: Cleared room data as last participant");
                    }
                    localStorage.removeItem('currentRoomId');
                    localStorage.removeItem(`currentUserId_${roomId}`);
                    window.location.href = 'index.html';
                });
            }
        },
        {
            text: 'ÂèñÊ∂à',
            class: 'btn-primary',
            onClick: () => {
                logDebug("leaveRoom: Cancel leave clicked");
            }
        }
    ], 'leave');
}

function generateVerificationCode() {
    const digits = Math.floor(Math.random() * 90 + 10).toString();
    const letters = String.fromCharCode(
        Math.floor(Math.random() * 26) + 97,
        Math.floor(Math.random() * 26) + 97
    );
    const code = digits + letters;
    logDebug(`generateVerificationCode: Generated code ${code}`);
    return code;
}
</script>
</head>
<body>
<h1>ÈÅ∏ÊìáÂ∞èÂπ´Êâã</h1>
<div class="page active" id="setupPage">
  <div class="header-row" style="justify-content: flex-end;">
    <button class="btn-primary" style="padding:6px 12px; font-size:14px;" onclick="leaveRoom()">üèÉ Èõ¢Èñã</button>
  </div>
  <h2>Âª∫Á´ã / Âä†ÂÖ•ÊàøÈñì</h2>
  <input type="text" id="roomNameInput" placeholder="ÊàøÈñìÂêçÁ®±" />
  <input type="text" id="verificationCodeInput" placeholder="È©óË≠âÁ¢ºÔºàÊñ∞ÊàøÈñìÂÖçÂ°´Ôºâ" />
  <input type="text" id="userNameInput" placeholder="‰Ω†ÁöÑÂêçÁ®±" />
  <button class="btn-primary" onclick="createRoom()">Âª∫Á´ã / Âä†ÂÖ•</button>
</div>
<div class="page" id="multiPage">
  <div class="header-row" style="justify-content: space-between;">
    <div style="display: flex; align-items: center; gap: 8px;">
      <span id="roomNameDisplay" style="font-weight:bold;"></span>
      <button class="btn-primary" style="padding:6px 12px; font-size:14px;" onclick="shareRoom()">ÂàÜ‰∫´</button>
    </div>
    <button class="btn-primary" style="padding:6px 12px; font-size:14px;" onclick="leaveRoom()">üèÉ Èõ¢Èñã</button>
  </div>
  <div><strong id="participantCount">ÂèÉËàáËÄÖ(0‰∫∫)Ôºö </strong>
    <div id="participantContainer" class="item-container"></div>
  </div>
  <div style="margin-top: 10px; text-align:left;">
    <button class="btn-primary" onclick="chooseDecisionMode()">Ê±∫ÂÆöÊñπÂºè</button>
    <span id="selectedMode" style="margin-left:8px; font-weight:bold; color:#2c3e50;"></span>
  </div>
  <div style="margin-top: 20px;"><strong>üìÉ Ê∏ÖÂñÆÈ†ÖÁõÆÔºö</strong>
    <div id="listContainer" class="item-container"></div>
    <input type="text" id="itemInput" placeholder="Ëº∏ÂÖ•È†ÖÁõÆ" onkeypress="if(event.key==='Enter') addItem();" />
    <div style="display:flex; gap:6px; margin-top:4px;">
      <button class="btn-primary" onclick="addItem()">Êñ∞Â¢ûÈ†ÖÁõÆ</button>
      <button class="btn-primary" onclick="importItems()">ÂåØÂÖ•</button>
    </div>
    <div style="margin-top:30px;">
      <button class="btn-confirm-red" onclick="requestConfirmation()">ÊàëÂêåÊÑèÊ≠§Ê∏ÖÂñÆ</button>
    </div>
  </div>
  <div id="multiDebugBox" class="debug-box"></div>
</div>
<div class="page" id="decidePage">
  <div class="header-row" style="justify-content: space-between;">
    <div>
      <span id="decideRoomNameDisplay" style="font-weight:bold;"></span>
      <span id="decideModeDisplay" style="margin-left:10px; font-weight:bold; color:#2c3e50;"></span>
    </div>
    <div style="display:flex; gap:6px;">
      <button class="btn-primary" style="padding:6px 12px; font-size:14px;" onclick="requestReedit()">‚Üê ÈáçÊñ∞Á∑®ËºØ</button>
      <button class="btn-primary" style="padding:6px 12px; font-size:14px;" onclick="leaveRoom()">üèÉ Èõ¢Èñã</button>
    </div>
  </div>
  <div>
    <strong id="decideParticipantCount">ÂèÉËàáËÄÖ(0‰∫∫)Ôºö</strong>
    <div id="decideParticipantContainer" class="item-container"></div>
  </div>
  <div style="text-align:center; margin-top: 30px;">
    <button class="btn-primary" onclick="startDraw()">üé≤ ÈñãÂßãÊäΩÁ±§</button>
    <div id="resultArea" style="font-size: 2em; margin-top: 20px;"></div>
  </div>
  <div id="decideDebugBox" class="debug-box"></div>
</div>
</body>
</html>

